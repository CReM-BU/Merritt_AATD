---
title: "Analysis 10X dataset"
output:
  html_document:
    fig_caption: yes
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: cerulean
editor_options:
  chunk_output_type: console
params:
  prefix: "combined_harmony"
  resDEG: "SCT_snn_res.0.25"
  percent.mito: 0.10
  cell.source: "human"
  harmonize: FALSE
  sample.names: !r c("WA_MC_1","WA_MC_2","WA_MC_3","WA_MC_4","WA_MC_5","WA_MC_6","WA_MC_7","WA_MC_8","WA_MC_9","WA_MC_10","WA_MC_11","WA_MC_12","WA_MC_13","WA_MC_14","WA_MC_15","WA_MC_16")
---


```{r setup, include=FALSE, cache=FALSE}
library(future)
# plan("multiprocess", workers = 8)
options(future.globals.maxSize = 8000 * 1024^2)

ifelse(dir.exists("/mnt/scc/project_workspace/"),
       cremwd <- "/mnt/scc/",
       cremwd <- "/restricted/projectnb/crem-bioinfo/")
master_path <- file.path(cremwd, "project_workspace/25_07_03_Carly/calculations/")
prefix <- 'combined_harmony'
calculations_path <- paste0(master_path, prefix, "/")
plots_path <- file.path(calculations_path, "plots/")
rds_path <- file.path(calculations_path, "rds/")
cache_path <- file.path(calculations_path, "cache/") # it must end in a slash
dir.create(rds_path, recursive = T)
dir.create(plots_path, recursive = T)

knitr::opts_chunk$set(echo = FALSE, message = FALSE,error = FALSE,warning = FALSE, cache = TRUE, cache.path = cache_path, fig.width=9,fig.height=7, autodep=TRUE, collapse = FALSE, fig.path = plots_path, fig.keep = "all", comment = "##", dev = c("png", "pdf"), cache.lazy = FALSE)   
options(tibble.print_max = 150)

library(tidyverse)
library(Seurat)
library(Matrix)
library(matrixStats) #rowVars
library(magrittr)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(data.table) # getting counts
library(knitr)
library(clustree)
library(patchwork)
library(harmony)
```


```{r load_objects, eval=FALSE}
sc <- readRDS(paste0(rds_path, "sc.Rds"))
```

```{r load_and_merge_from_scratch, eval=T}

seu.list <- list()
sample.names <- params$sample.names
for (i in 1:length(sample.names)) {
  seu.list[[i]] <- readRDS(paste0(master_path,"/analysis/", sample.names[i], "/rds/sc.Rds"))
 #seu.list[[i]] <- UpdateSeuratObject(seu.list[[i]])
  seu.list[[i]]@project.name <- sample.names[i]
  #seu.list[[i]]$orig.ident <- sub("KD_AA_0304_", "", seu.list[[i]]$orig.ident)
  DefaultAssay(seu.list[[i]]) <- "RNA" # make default RNA, so that SCT can be removed
  seu.list[[i]] <- DietSeurat(seu.list[[i]], counts = TRUE, scale.data = FALSE, assays = "RNA")
}
sc <- merge(seu.list[[1]], y = seu.list[-1], project = "sc")
#sc$annot <- paste0(sc$orig.ident, "_EPCAM_", sc$EPCAM_state)
```

```{r loadsample, eval=FALSE}
sc1=readRDS("/restricted/projectnb/crem-bioinfo/project_workspace/24_03_14_andrea/calculations/analysis/combined_without_D63Tplus/rds/sc.update.ER.Rds")
Idents(sc1)="orig.ident"
sc=subset(sc1,idents=c("D17Tplus","D26Tplus","D26Tminus"))
```

# QC filtering

```{r load_sc_qc, fig.height=4}
#cat("UMI counts per cell")
#summary(apply(GetAssayData(sc, slot = "counts"), 2, sum))
#cat("UMI counts per gene")
#summary(apply(GetAssayData(sc, slot = "counts"), 1, sum))

sc$orig.ident2 <- sc$orig.ident # store for future reference

sc$orig.ident <- plyr::mapvalues(
  sc$orig.ident,
  c(
    "WA_MC_1", "WA_MC_2", "WA_MC_3", "WA_MC_4", "WA_MC_5", "WA_MC_6",
    "WA_MC_7", "WA_MC_8", "WA_MC_9", "WA_MC_10", "WA_MC_11", "WA_MC_12",
    "WA_MC_13", "WA_MC_14", "WA_MC_15", "WA_MC_16"
  ),
  c(
    "wt_1",   # WA_MC_1
    "M_2",    # WA_MC_2
    "wt_3",   # WA_MC_3
    "wt_4",   # WA_MC_4
    "wt_5",   # WA_MC_5
    "M_6",    # WA_MC_6
    "M_7",    # WA_MC_7
    "M_8",    # WA_MC_8
    "Z_9",    # WA_MC_9
    "Z_10",   # WA_MC_10
    "M_11",   # WA_MC_11
    "M_12",   # WA_MC_12
    "Z_13",   # WA_MC_13
    "Z_14",   # WA_MC_14
    "wt_15",  # WA_MC_15
    "wt_16"   # WA_MC_16
  )
)

Idents(sc) <- "orig.ident"

cat("After filtering doublets and degraded cells")
p <- VlnPlot(sc, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), pt.size = 0.1) 
p <- p & ggmin::theme_powerpoint() & theme(axis.title.x = element_blank()) & NoLegend() & RotatedAxis()
p
ggsave(paste0(plots_path, "Vln.qc.after.pdf"), height = 4, width = 5)
sc


#p <- VlnPlot(sc, features = c("TBX4", "TBX5", "FOXF1", "PTCH1", "GLI1", "WNT2","MSC", "WNT4","WT1","KDR","HAND1","PRRX1"),stack = TRUE,flip = TRUE, pt.size = 0.1) 
#p <- p & ggmin::theme_powerpoint() & theme(axis.title.x = element_blank()) & NoLegend() & RotatedAxis()
#p
#ggsave(paste0(plots_path, "Vln.qc.after.pdf"))


#p <- Stacked_VlnPlot(seurat_object = sc, features = c("TBX4", "TBX5", "FOXF1", "PTCH1", "GLI1", "WNT2","MSC", "WNT4","WT1","KDR","HAND1","PRRX1"), x_lab_rotate = TRUE)

#ncols=c('#F8766D','#F8766D','#F8766D','#1F78B4','#1F78B4','#1F78B4','#1F78B4')

```
# Dimensionality reduction

Regressing out the confounding effect of cell degradation (by modeling the mitochondrial percentage as a latent variable).

```{r dim_red_pca}
sc <- SCTransform(sc, vars.to.regress=c("percent.mito","percent.mt"), verbose = FALSE) %>% RunPCA(verbose = FALSE)
ElbowPlot(sc, 50)
#ggsave(paste0(plots_path, "elbow.pdf"))

if(params$harmonize) {
  sc <- RunHarmony(sc, assay.use = "SCT", group.by.vars = "orig.ident")
  p1 <- DimPlot(sc, reduction = "pca", group.by = "orig.ident")
  p2 <- DimPlot(sc, reduction = "harmony", group.by = "orig.ident")
  p <- p1 + p2 & ggmin::theme_powerpoint() & NoAxes()
  print(x = sc[['harmony']], dims = 1:5, nfeatures = 5, projected = FALSE)
} else {
  p <- DimPlot(sc, reduction = "pca", group.by = "orig.ident") & ggmin::theme_powerpoint() & NoAxes()
  print(x = sc[['pca']], dims = 1:5, nfeatures = 5, projected = FALSE)
}
p
```

These are the genes driving the first 9 principal components

```{r dim_heatmap, fig.height=11}
if(params$harmonize) {
  DimHeatmap(sc, reduction = "harmony", dims = 1:9, cells = 500, balanced = TRUE)
  } else {
  DimHeatmap(sc, dims = 1:9, cells = 500, balanced = TRUE)
}
```

# Clustering

Use UMAP for non-linear dimensionality reduction

Use Louvain algorithm for community detection.

```{r cluster_and_rdim, eval=TRUE, results=FALSE}
if(params$harmonize) {
  sc <- FindNeighbors(sc , reduction = "harmony", dims = 1:40, graph.name = "Harmony")        
  sc <- FindClusters(sc, resolution = seq(1.5, 0.25, -0.25), graph.name = "Harmony") # reverse order, seurat_clusters takes last run's value
  sc <- FindClusters(sc, resolution = seq(0.20, 0.05, -0.05), graph.name = "Harmony") # reverse order, seurat_clusters takes last run's value
  sc <- RunUMAP(sc, reduction = "harmony", dims = 1:40)
  } else {
  sc <- FindNeighbors(sc, dims = 1:30)
  sc <- FindClusters(sc, resolution = seq(0.20, 0.05, -0.05)) # reverse order, seurat_clusters takes last run's value
  sc <- FindClusters(sc, resolution = seq(1.5, 0.25, -0.25)) # reverse order, seurat_clusters takes last run's value
  sc <- RunUMAP(sc, dims = 1:30)
}

```

Non-linear dimensionality reduction with UMAP

```{r plot_rdim}
DimPlot(sc, group.by = "orig.ident") + ggmin::theme_powerpoint()
#ggsave(paste0(plots_path, "UMAP.color.by.orig.ident.pdf"), width = 8, height = 7)
```


# Cell-cycle stage classification

Score G1, G2/M and S signatures in each cell.

Classify phase based on that score.

```{r CC_regression, eval=TRUE}
if(params$cell.source == "human") {
  s.genes <- cc.genes.updated.2019$s.genes
  g2m.genes <- cc.genes.updated.2019$g2m.genes
} else {
  s.genes <- firstup(cc.genes.updated.2019$s.genes)
  g2m.genes <- firstup(cc.genes.updated.2019$g2m.genes)
}
sc <- CellCycleScoring(sc, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)  
grouping <- "Phase"; DimPlot(sc, reduction = "umap", group.by =  grouping) + ggmin::theme_powerpoint()

kable(table(sc$Phase, sc[[params$resDEG]][[1]]), caption="Cell cycle stage classification per 
cluster") %>%   kable_styling() %>%   scroll_box(width = "100%", height = "200px")
```

# Molecular Signatures scoring

Compute enrichment for molecular signatures using method from Tirosh et al, Science (2016)    

```{r mol_sig, fig.height=11, eval=FALSE}
msig <- scan(paste0(cremwd, "/reference_data/gene_sets/lung.matur.differ.MSig.txt"), what="", sep="\n") # Read in the data
msig <- sapply(msig, function(k) gsub(",$", "", k))
msig <- strsplit(msig, ",[[:space:]]+")  # Separate elements by a comma and one or more whitepace
names(msig) <- sapply(msig, `[[`, 1)  # subset the first vector element and set it as the list element name
msig <- lapply(msig, `[`, -1) # Remove the first vector element from each list element        
sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/19_09_10_darrell_habermann/calculations/analysis/habermann//rds/sc.markers.wilcox.celltype.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Hb_", sc.markers.wilcox.res[[2]]$cluster)  # habermann et al msig

msig2 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)

msig3 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea.msig.xlsx"), sheet=1))
msig3 <- lapply(msig3, function(x) x[!is.na(x)])

msig5 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea_ER_Genesets.xlsx"), sheet=1))
msig5 <- lapply(msig5, function(x) x[!is.na(x)])
msig5 <- msig5[-1]
names(msig5) <- paste0('ER_', names(msig5))

msig6 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/EarlyFibro_minusCC.xlsx"), sheet=1))
msig6 <- lapply(msig6, function(x) x[!is.na(x)])


msig <- c(msig, msig2)

genes <- c('COL1A1','ACTA2','FN1','CTHRC1','CTGF')
msig[[36]] <- genes
names(msig)[36] <- "Fibrotic_markers"

sc.markers.res <- as.list(readxl::read_excel(paste0(cremwd, "project_workspace/23_09_11_andrea/calculations/analysis/combined/TopMarkers_celltype_level3.xls")))
msig4 <- split(sc.markers.res$feature, sc.markers.res$group)

msig <- c(msig)

sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/24_03_14_andrea/calculations/analysis/combined_without_D63Tplus/rds/sc.markers.mas.subset.01.SCT_snn_res.0.5.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Top50_Cluster_", sc.markers.wilcox.res[[2]]$cluster)
msig7 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)

msig7[['Top50_Cluster_4_subset']] <- c('H19','ACTG1','SFRP2','SULT1E1','GABPB1-AS1','AC024940.2','NAP1L1','CCND2','DES','BCL11A','MT-TP','IGF2BP2','SNAI2','SLITRK6','MAGED2','UNC5C','NRP2','BCAT1','NKAIN4','PCDH18','MME','TNFRSF19','CTSC','GNAO1','PLAC9','L1TD1','SCN7A','FN1','HIPK2')


names(msig) <- sub("\\+", "pos", names(msig))
names(msig) <- sub("-", "neg", names(msig))
names(msig) <- make.names(names(msig))
if(params$cell.source == "mouse") {
    msig <- lapply(msig, firstup)
}



sc <- AddModuleScore(sc, features = msig, name = names(msig), search = T)
sc <- AddMetaData(sc, sc[[paste0(names(msig), 1:length(names(msig)))]], col.name = names(msig))
for(i in paste0(names(msig), 1:length(names(msig)))) {
  sc[[i]] <- NULL
}
```


```{r mol_sig_score, fig.height=11, eval=T}
msig <- scan(paste0(cremwd, "/reference_data/gene_sets/lung.matur.differ.MSig.txt"), what="", sep="\n") # Read in the data
msig <- sapply(msig, function(k) gsub(",$", "", k))
msig <- strsplit(msig, ",[[:space:]]+")  # Separate elements by a comma and one or more whitepace
names(msig) <- sapply(msig, `[[`, 1)  # subset the first vector element and set it as the list element name
msig <- lapply(msig, `[`, -1) # Remove the first vector element from each list element        
sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/19_09_10_darrell_habermann/calculations/analysis/habermann//rds/sc.markers.wilcox.celltype.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Hb_", sc.markers.wilcox.res[[2]]$cluster)  # habermann et al msig
msig2 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)
#msig3 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea.msig.xlsx"), sheet=1))
#msig3 <- lapply(msig3, function(x) x[!is.na(x)])

msig <- c(msig, msig2)

#genes <- c('COL1A1','ACTA2','FN1','CTHRC1','CTGF')
#msig[[51]] <- genes
#names(msig)[51] <- "Fibrotic_markers"

#sc.markers.res <- as.list(readxl::read_excel(paste0(cremwd, "project_workspace/23_09_11_andrea/calculations/analysis/combined/TopMarkers_celltype_level3.xls")))
#msig4 <- split(sc.markers.res$feature, sc.markers.res$group)

#msig <- c(msig)
#msig <- msig[c(-3,-4)]
#msig <- msig[-1]
#msig <- msig[-70]

names(msig) <- sub("\\+", "pos", names(msig))
names(msig) <- sub("-", "neg", names(msig))
names(msig) <- make.names(names(msig))
if(params$cell.source == "mouse") {
    msig <- lapply(msig, firstup)
}



sc <- AddModuleScore(sc, features = msig, name = names(msig), search = T, nbin = 10,ctrl = 10)
sc <- AddMetaData(sc, sc[[paste0(names(msig), 1:length(names(msig)))]], col.name = names(msig))
for(i in paste0(names(msig), 1:length(names(msig)))) {
  sc[[i]] <- NULL
}
```


# UMAP clusters

```{r facetted_louvain_clusters_UMAP, fig.height=6}
if(params$harmonize) {
  grouping <- "Harmony_res.0.1";  p1 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.15"; p2 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.2";  p3 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.25"; p4 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.5";  p5 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.75"; p6 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  } else {
  grouping <- "SCT_snn_res.0.1";  p1 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.15"; p2 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.2";  p3 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.25"; p4 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.5";  p5 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.75"; p6 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
}
p <- p1 + p2 + p3 + p4 + p5 + p6
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
p
ggsave(paste0(plots_path, "UMAP.clust.pdf"), width = 10, height = 7)
```

# UMAP pre-selected features

```{r echo=FALSE}
# 4 columns, 9 width, height per line == 9 / 4 == 2.25
x <- interesting_feats <- c("nFeature_RNA", "nCount_RNA", "percent.mito", names(msig), interesting_genes)
len <- (length(unique(x))/4)*2.25
```

```{r pre_selected_marker_genes_UMAP,  fig.height=len}
interesting_feats <- c("nFeature_RNA", "nCount_RNA", "percent.mito", names(msig), interesting_genes)
p <- FeaturePlot(sc, features = interesting_feats, cols = c("#f0f0f0", brewer.pal(9,"OrRd")))
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
p
ggsave(paste0(plots_path, "UMAP.preselected.feats.pdf"),limitsize = FALSE)
```

# Azimuth

```{r annotate, eval=FALSE}
# Seurat 5.3.0 had bugs affecting Azimuth transfer anchors function
# update to 5.3.1 or downgrade to 5.2.x
devtools::install_github("satijalab/seurat") # main is 5.3.1, bug fixed already
# remotes::install_version("Seurat", "5.2.1")
library(Azimuth)
library(SeuratData)

# Load your query Seurat object (replace "query.rds")
sc

# ref <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/ref.Rds")

# # Choose your reference (for example, use PBMC reference)
# reference <- Azimuth::LoadReference("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/")
# sc_test <- JoinLayers(sc, assay = "RNA") # Fix to bug: https://github.com/satijalab/seurat/issues/8368
# 
# # Check if these common genes are present in the query dataset's RNA assay
# common_ref_genes <- readRDS(paste0(dir_ref, "ref_genes.Rds"))
# common_in_query <- common_ref_genes[common_ref_genes %in% rownames(sc[["SCT"]])]
# # Output missing genes (if any)
# missing_genes <- common_ref_genes[!common_in_query]
# if (length(missing_genes) > 0) {
#   print(paste("Missing genes in query data:", paste(missing_genes, collapse = ", ")))
# } else {
#   print("All features are present in query data.")
# }
# 
# 
# sc_annot <- RunAzimuth(query = sc_test, reference = "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/",
#                        assay = "SCT",
#                        annotation.levels = "Main_cell_type",
#                        umap.name = "refUMAP")
# sc_annot_hs <- RunAzimuth(sc, reference = "lungref")

```

## Run - tested OK

```{r}
query <- sc
assay <- "SCT"
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"

reference <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"
reference <- LoadReference(reference)$map
dims <- as.double(slot(reference, "neighbors")$refdr.annoy.neighbors@alg.info$ndim)
reference.version <- ReferenceVersion(reference)
azimuth.version <- as.character(packageVersion(pkg = "Azimuth"))
seurat.version <- as.character(packageVersion(pkg = "Seurat"))
meta.data <- names(slot(reference, "meta.data"))
annotation.levels <- names(slot(object = reference, name = "meta.data"))
annotation.levels <- annotation.levels[!grepl(pattern = "^nCount", x = annotation.levels)]
annotation.levels <- annotation.levels[!grepl(pattern = "^nFeature", x = annotation.levels)]
annotation.levels <- annotation.levels[!grepl(pattern = "^ori", x = annotation.levels)]
# query <- ConvertGeneNames(
#       object = query,
#       reference.names = rownames(x = reference),
#       homolog.table = 'https://seurat.nygenome.org/azimuth/references/homologs.rds'
#     )
# Calculate nCount_RNA and nFeature_RNA if the query does not
# contain them already
if (!all(c("nCount_RNA", "nFeature_RNA") %in% c(colnames(x = query[[]])))) {
  calcn <- as.data.frame(x = Seurat:::CalcN(object = query[[assay]]))
  colnames(x = calcn) <- paste(colnames(x = calcn), assay, sep = '_')
  query <- AddMetaData(object = query, metadata = calcn)
  rm(calcn)
}

# Calculate percent mitochondrial genes if the query contains genes
# matching the regular expression "^MT-"
if (any(grepl(pattern = '^mt-', x = rownames(x = query)))) {
  query <- PercentageFeatureSet(
    object = query,
    pattern = '^mt-',
    col.name = 'percent.mt',
    assay = assay
  )
}

umap.name = "ref.umap"
do.adt = FALSE
verbose = TRUE
assay = NULL
k.weight = 50
n.trees = 20
mapping.score.k = 100
#    features = rownames(Loadings(reference[["refDR"]]))

query <- JoinLayers(query, assay = "RNA")
common_ref_genes <- readRDS(paste0(dir_ref, "ref_genes.Rds"))
common_in_query <- common_ref_genes[common_ref_genes %in% rownames(sc[["SCT"]])] # See: https://github.com/satijalab/seurat/issues/4019

# Find anchors between query and reference
anchors <- FindTransferAnchors(
  reference = reference,
  query = query,
  k.filter = NA,
  reference.neighbors = "refdr.annoy.neighbors",
  reference.assay = "refAssay",
  query.assay = assay,
  reference.reduction = "refDR",
  normalization.method = "SCT",
  features = common_in_query,
  dims = 1:dims,
  n.trees = n.trees,
  mapping.score.k = mapping.score.k,
  verbose = verbose
)
# Transferred labels are in metadata columns named "predicted.*"
# The maximum prediction score is in a metadata column named "predicted.*.score"
# The prediction scores for each class are in an assay named "prediction.score.*"
# The imputed assay is named "impADT" if computed
refdata <- lapply(X = annotation.levels, function(x) {
  reference[[x, drop = TRUE]]
})
names(x = refdata) <- annotation.levels


query <- TransferData(
  reference = reference,
  query = query,
  query.assay = assay,
  dims = 1:dims,
  anchorset = anchors,
  refdata = refdata,
  n.trees = 20,
  store.weights = TRUE,
  k.weight = k.weight,
  verbose = verbose
)
# Calculate the embeddings of the query data on the reference SPCA
query <- IntegrateEmbeddings(
  anchorset = anchors,
  reference = reference,
  query = query,
  query.assay = assay,
  reductions = "pcaproject",
  reuse.weights.matrix = TRUE,
  verbose = verbose
)
#     # Calculate the query neighbors in the reference
#     # with respect to the integrated embeddings
query[["query_ref.nn"]] <- FindNeighbors(
  object = Embeddings(reference[["refDR"]])[,1:ncol(Embeddings(query[["integrated_dr"]]))],
  query = Embeddings(query[["integrated_dr"]]),
  return.neighbor = TRUE,
  l2.norm = TRUE,
  verbose = verbose
)
#     # Error: fv.size() != vector_size. See: https://github.com/satijalab/seurat/issues/4019
#     # The reference used in the app is downsampled compared to the reference on which
#     # the UMAP model was computed. This step, using the helper function NNTransform,
#     # corrects the Neighbors to account for the downsampling.
#     query <- NNTransform(
#       object = query,
#       meta.data = reference[[]]
#     )
#     #Error in NNTransform(object = query, meta.data = reference[[]]) : 
# #   could not find function "NNTransform"
#   
#     # Project the query to the reference UMAP.
query[[umap.name]] <- RunUMAP(
  object = query[["query_ref.nn"]],
  reduction.model = reference[["refUMAP"]],
  reduction.key = 'UMAP_',
  verbose = verbose
)
# Calculate mapping score and add to metadata
query <- AddMetaData(
  object = query,
  metadata = MappingScore(anchors = anchors, ndim = dims),
  col.name = "mapping.score"
)

saveRDS(query, paste0(rds_path, "sc.Rds"))

```

## EDA Azimuth rst

```{r}
query[[]] %>%
    group_by(predicted.Main_cell_type, experiment) %>%
    dplyr::summarize(Mean.pred = mean(predicted.Main_cell_type.score, na.rm=TRUE),
                     Mean.map = mean(mapping.score, na.rm=TRUE)
                     )

table(query[[]]$annot_supervised, query[[]]$predicted.Main_cell_type)
table(query[[]]$predicted.Main_cell_type, query[[]]$annot_supervised)

grouping <- "predicted.Main_cell_type"
p1 <- DimPlot(query, group.by = grouping, label = T) + labs(title = grouping)
p1 <- p1 & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
ggsave(paste0(plots_path, "UMAP.Azimuth.pdf"), p1, width = 10, height = 10)
View(head(query[[]]))
grouping <- "predicted.Lineage"
p2 <- DimPlot(query, group.by = grouping, label = T) + labs(title = grouping)
p2 <- p2 & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
ggsave(paste0(plots_path, "UMAP.Lineage.pdf"), p2, width = 10, height = 10)

p <- p1 + p2
ggsave(paste0(plots_path, "UMAP.both_annot.pdf"), p, width = 20, height = 10)


interesting_feats <- c("predicted.Main_cell_type.score", "mapping.score")
p <- FeaturePlot(query, features = interesting_feats) & scale_color_viridis_c(option = "viridis")
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()

ggsave(paste0(plots_path, "UMAP.azimuth.scores.pdf"),p , width = 20, height = 10)
```


## Prep reference files


Required files for scRNAseq queries

File 1: ref.Rds Seurat object
Assay: 
SCTAssay named refAssay with a single SCTransform model stored in the SCTModel.list slot called "refmodel"

DimReducs
2 DimReduc: 
refUMAP
  misc slot of refUMAP containeds an element named "model":
  RunUMAP called with umap.method = "uwot", return.model = TRUE
and refDR 
  at least 50 dim
  associated with "refAssay" i.e. DefaultAssay(object[[“refDR”]]) returns "refAssay"

Neighbors
Neighbor object containing precomputed ref neighborhoods stored as refdr.annoy.neighbors. Computed of the refDR DimReduc using the first 50 dims

Tools
plotref
colormap

Metadata: any to be transfered to query and "ori.index"

File 2: index.annoy
GEnerated when computing refdr.annoy.neighbors


```{r, build_reference}
#!/usr/bin/env Rscript

# Script to build mouse pansci reference 1.0.0

# rule build_reference:
#     input:
#         script = "scripts/build_reference.R",
#         obj = "data/obj.rds",
#         annotations = "data/pansci_genenames.csv",
#     output:
#         ref = "reference/ref.Rds",
#         idx = "reference/idx.annoy",
#         obj = "full_reference.Rds"
#     shell:
#         """
#         Rscript {input.script} {input.obj} {input.genenames} {output.ref} {output.idx} {output.obj}
#         """

# Rscript {input.script} {input.counts} {input.genenames} {input.dr} {output.ref} {output.idx} {output.obj}

library(Azimuth)
library(glmGamPoi)

obj_original <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_filtered.rds")
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"
dir.create(dir_ref)
azimuth.reference <- paste0(dir_ref, "ref.Rds")
azimuth.index <- paste0(dir_ref, "idx.annoy")
# full.reference <- paste0(dir_ref, "pansci.Rds")
full.reference <- paste0(dir_ref, "pansci_subset.Rds")

colnames(obj_original[[]])
obj_original[[]] %>% dplyr::count(Organ_name, Main_cell_type, Lineage)
obj_original_sub <- subset(obj_original, Organ_name == "Lung")

# Convert gene IDs to gene symbols based on annotations file 
pansci.mtx <- LayerData(obj_original_sub, assay="RNA", layer="counts")
nonzero <- pansci.mtx > 0
keep_genes <- Matrix::rowSums(nonzero) >= 10; table(keep_genes)
obj_original_sub[["RNA"]][[]]$keep_genes <- keep_genes
gene_names <- obj_original_sub[["RNA"]][[]] %>% filter(keep_genes)
length(unique(gene_names$gene_name))
length(gene_names$gene_name)
length(unique(gene_names$gene_id))
length(gene_names$gene_id)

subset.pansci.mtx <- pansci.mtx[keep_genes, ]
dim(subset.pansci.mtx)
all(rownames(subset.pansci.mtx) == gene_names$gene_id)
rownames(subset.pansci.mtx) <- gene_names$gene_name
table(gene_names$gene_type)         
# Rebuild object from RNA assay and converted gene names
pansci.assay <- CreateAssayObject(counts = subset.pansci.mtx)

obj <- CreateSeuratObject(counts=pansci.assay, assay="RNA")
obj <- AddMetaData(obj, obj_original_sub[[]])
rownames(gene_names) <- rownames(obj)
obj[["RNA"]][[]] <- gene_names
dim(gene_names)
rownames(obj[["RNA"]])
obj[[]]
# Normalize with SCT
obj <- SCTransform(obj, vst.flavor = "v2", method = "glmGamPoi", verbose = TRUE)
saveRDS(obj, full.reference)

# Run PCA on the SCT residuals 
obj <- RunPCA(obj, assay = "SCT", reduction.name = "pca", npcs = 100)

# Build UMAP model 
obj <- RunUMAP(obj, dims = 1:50, return.model = T)

SCT_feats <- obj[["RNA"]][[]][ rownames(obj[["SCT"]][[]]) , ]
obj[["SCT"]][[]] <- SCT_feats
SCT_feats %>% dplyr::count(gene_type, sort = T)
saveRDS(obj, full.reference)
dim(obj[["SCT"]][[]])
obj$Main_cell_type <- droplevels(obj$Main_cell_type)
obj$Lineage <- droplevels(obj$Lineage)
mapping.ob <- obj
plotref <- obj[["umap"]]

set.seed(28)
ids <- sample(
  x = levels(as.factor(mapping.ob$Main_cell_type)),
  size = length(levels(as.factor(mapping.ob$Main_cell_type)))
)
colormap.ids <- scales::hue_pal()(n = length(x = ids))
names(x = colormap.ids) <- ids
colormap.ids <- colormap.ids[sort(x = names(x = colormap.ids))]

colormap <- list(
  Lineage = CreateColorMap(ids = unique(x = obj$Lineage)),
  Main_cell_type = colormap.ids
)


# Build Azimuth Reference
azimuth.obj <- AzimuthReference(obj,
                        refUMAP='umap',
                        refDR='pca',
                        refAssay = 'SCT',
                        plotref = plotref,
                        dims = 1:50,
                        k.param = 31,  
                        metadata = c("Main_cell_type", "Lineage"),
                        reference.version = "Lung_subset",
                        colormap = colormap
)
azimuth.obj[["SCT"]] <- azimuth.obj[["refAssay"]]
DefaultAssay(sc) <- "SCT"
ValidateAzimuthReference(object = azimuth.obj)

SaveAnnoyIndex(
  object = azimuth.obj[["refdr.annoy.neighbors"]],
  file = azimuth.index
)
saveRDS(
  object = azimuth.obj,
  file = azimuth.reference
)

azimuth.obj <- readRDS(azimuth.reference)
reference_pca_genes <- rownames(Loadings(azimuth.obj[["refDR"]]))
reference_rna_genes <- rownames(azimuth.obj[["refAssay"]])
common_ref_genes <- intersect(reference_pca_genes, reference_rna_genes)
saveRDS(common_ref_genes, paste0(dir_ref, "ref_genes.Rds"))



```

Full object test

```{r}
obj_original <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_filtered.rds")
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_full/"
dir.create(dir_ref)
azimuth.reference <- paste0(dir_ref, "ref.Rds")
azimuth.index <- paste0(dir_ref, "idx.annoy")
# full.reference <- paste0(dir_ref, "pansci.Rds")
full.reference <- paste0(dir_ref, "pansci_full.Rds")

colnames(obj_original[[]])
obj_original[[]] %>% dplyr::count(Organ_name, Main_cell_type, Lineage)
# obj_original_sub <- subset(obj_original, Organ_name == "Lung")

# Convert gene IDs to gene symbols based on annotations file 
pansci.mtx <- LayerData(obj_original, assay="RNA", layer="counts")
nonzero <- pansci.mtx > 0
keep_genes <- Matrix::rowSums(nonzero) >= 10; table(keep_genes)
obj_original[["RNA"]][[]]$keep_genes <- keep_genes
gene_names <- obj_original[["RNA"]][[]] %>% filter(keep_genes)
length(unique(gene_names$gene_name))
length(gene_names$gene_name)
length(unique(gene_names$gene_id))
length(gene_names$gene_id)

subset.pansci.mtx <- pansci.mtx[keep_genes, ]
dim(subset.pansci.mtx)
all(rownames(subset.pansci.mtx) == gene_names$gene_id)
rownames(subset.pansci.mtx) <- gene_names$gene_name
table(gene_names$gene_type)         
# Rebuild object from RNA assay and converted gene names
pansci.assay <- CreateAssayObject(counts = subset.pansci.mtx)

obj <- CreateSeuratObject(counts=pansci.assay, assay="RNA")
obj <- AddMetaData(obj, obj_original[[]])
rm(obj_original)
rm(pansci.mtx)
rm(subset.pansci.mtx)
rm(pansci.assay)
gc()
rownames(gene_names) <- rownames(obj)
obj[["RNA"]][[]] <- gene_names
dim(gene_names)
rownames(obj[["RNA"]])
obj[[]]
# Normalize with SCT
obj <- SCTransform(obj, vst.flavor = "v2", method = "glmGamPoi", verbose = TRUE, conserve.memory = TRUE)
saveRDS(obj, full.reference)

# Run PCA on the SCT residuals 
obj <- RunPCA(obj, assay = "SCT", reduction.name = "pca", npcs = 50)

# Build UMAP model 
obj <- RunUMAP(obj, dims = 1:50, return.model = T)

SCT_feats <- obj[["RNA"]][[]][ rownames(obj[["SCT"]][[]]) , ]
obj[["SCT"]][[]] <- SCT_feats
SCT_feats %>% dplyr::count(gene_type, sort = T)
saveRDS(obj, full.reference)
obj <- readRDS(full.reference)

dim(obj[["SCT"]][[]])
# obj$Main_cell_type <- droplevels(obj$Main_cell_type)
# obj$Lineage <- droplevels(obj$Lineage)
mapping.ob <- obj
plotref <- obj[["umap"]]

set.seed(28)
ids <- sample(
  x = levels(as.factor(mapping.ob$Main_cell_type)),
  size = length(levels(as.factor(mapping.ob$Main_cell_type)))
)
colormap.ids <- scales::hue_pal()(n = length(x = ids))
names(x = colormap.ids) <- ids
colormap.ids <- colormap.ids[sort(x = names(x = colormap.ids))]



colormap <- list(
  Lineage = CreateColorMap(ids = unique(x = obj$Lineage)),
  Main_cell_type = colormap.ids,
  Organ_name = CreateColorMap(ids = unique(x = obj$Organ_name)),
  Sub_cell_type = CreateColorMap(ids = unique(x = obj$Sub_cell_type))
)


# Build Azimuth Reference
azimuth.obj <- AzimuthReference(obj,
                        refUMAP='umap',
                        refDR='pca',
                        refAssay = 'SCT',
                        plotref = plotref,
                        dims = 1:50,
                        k.param = 31,  
                        metadata = c("Main_cell_type", "Lineage", "Organ_name", "Sub_cell_type"),
                        reference.version = "Full_pansci",
                        colormap = colormap
)
azimuth.obj[["SCT"]] <- azimuth.obj[["refAssay"]]
DefaultAssay(sc) <- "SCT"
ValidateAzimuthReference(object = azimuth.obj)

SaveAnnoyIndex(
  object = azimuth.obj[["refdr.annoy.neighbors"]],
  file = azimuth.index
)
saveRDS(
  object = azimuth.obj,
  file = azimuth.reference
)

azimuth.obj <- readRDS(azimuth.reference)
reference_pca_genes <- rownames(Loadings(azimuth.obj[["refDR"]]))
reference_rna_genes <- rownames(azimuth.obj[["refAssay"]])
common_ref_genes <- intersect(reference_pca_genes, reference_rna_genes)
saveRDS(common_ref_genes, paste0(dir_ref, "ref_genes.Rds"))

```{r feedback_DEG, eval=FALSE}
all(sc$seurat_clusters == sc$SCT_snn_res.0.25) # TRUE
sc$annot_supervised <- fct_recode(sc$seurat_clusters,
            "endothelial"    = "0",
            "AT2"            = "1",
            "fibroblasts"    = "2",
            "AT2"            = "3",
            "AT2"            = "4",
            "AT2"            = "5",
            "AT2"            = "6",
            "endothelial"    = "7",
            "AT2"            = "8",
            "endothelial"    = "9",
            "monocytes/macrophages" = "10",
            "ciliated"       = "11",
            "AT2"            = "12",
            "B cells"        = "13",
            "AT2"            = "14",
            "fibroblasts"   = "15",
            "T/NK cells"     = "16",
            "AT2"            = "17",
            "club cells"   = "18",
            "AT1"            = "19",
            "undetermined"   = "20",
            "basal cells"   = "21",
            "AT2"            = "22",
            "undetermined"   = "23",
            "undetermined"   = "24",
            "endothelial"    = "25",
            "endothelial"    = "26",
            "AT2"            = "27"
)
Idents(sc) <- "annot_supervised"
table(sc$annot_supervised, sc$seurat_clusters)
sc_subset <- subset(sc, idents = "AT2")
DefaultAssay(sc_subset) <- "RNA"
sc_subset <- DietSeurat(sc_subset, counts = TRUE, scale.data = FALSE, assays = "RNA")
sc_subset <- SCTransform(sc_subset, vars.to.regress="percent.mito", verbose = FALSE) %>% RunPCA(verbose = FALSE)
sc_subset <- FindNeighbors(sc_subset, dims = 1:30)
for(i in grep("^SCT", names(sc_subset[[]]), value = T)) {
  sc_subset[[i]] <- NULL
}
sc_subset[["seurat_clusters"]] <- NULL
sc_subset <- FindClusters(sc_subset, resolution = seq(0.20, 0.05, -0.05)) # reverse order, seurat_clusters takes last run's value
sc_subset <- FindClusters(sc_subset, resolution = seq(1.5, 0.25, -0.25)) # reverse order, seurat_clusters takes last run's value
sc_subset$SCT_snn_res.0.05
sc_subset <- RunUMAP(sc_subset, dims = 1:30)
DimPlot(sc_subset, group.by = "SCT_snn_res.0.05") + ggmin::theme_powerpoint()
# Proportion plot for SCT_snn_res.0.05
FeaturePlot(sc_subset, features = c("Lyz1", "Aqp5","Sftpc", "Cdkn1a", "Krt8"))
# recluster AT2s and do DEG between Z and wild type AT2s and Z and M AT2s and M and wild type

saveRDS(sc_subset, paste0(rds_path, "sc_subset.AT2.Rds"))
sc_subset <- readRDS(paste0(rds_path, "sc_subset.AT2.Rds"))

scCustomize::Proportion_Plot(sc_subset, plot_type = "bar",  plot_scale = "percent",  group_by_var = "experiment", split.by = "SCT_snn_res.0.05")

# ShinyCell


```{r ShinyCellxplorer}
library(Seurat)
devtools::install_github("SGDDNB/ShinyCell")

library(ShinyCell)
library(data.table)
library(Signac)
dir.create(paste0(calculations_path, "shinycell"))
setwd(paste0(calculations_path, "shinycell"))
sc <- readRDS(paste0(rds_path, "sc.Rds"))
var_features <- VariableFeatures(sc)
saveRDS(var_features, "var_features.rds")

seu <- sc
scConf <- createConfig(seu)
makeShinyApp(seu, scConf, gex.assay = c("SCT"), gene.mapping = TRUE , shiny.title = "x" , shiny.footnotes='Center for Regenerative Medicine', shiny.dir=paste0(calculations_path, "shinycell")) 

cd /restricted/projectnb/crem-bioinfo/project_workspace/test
cp cellxwoprest/cellxplorer/server.R  /restricted/projectnb/crem-bioinfo//project_workspace/25_07_03_Carly/calculations/combined_harmony/shinycell/server.R
cp cellxwoprest/cellxplorer/ui.R /restricted/projectnb/crem-bioinfo//project_workspace/25_07_03_Carly/calculations/combined_harmony/shinycell/ui.R
```


```{r azi}
#sc <- readRDS(paste0(rds_path, "sc.Rds"))
library(Azimuth)
library(SeuratData)

DefaultAssay(sc) <- "RNA"
sc[["RNA"]] <- JoinLayers(sc[["RNA"]])
sc <- RunAzimuth(sc, reference = "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_full/")

saveRDS(sc, paste0(rds_path, "sc.Rds"))
```
