---
title: "Analysis 10X dataset"
output:
  html_document:
    fig_caption: yes
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: cerulean
editor_options:
  chunk_output_type: console
params:
  prefix: "combined_harmony"
  resDEG: "SCT_snn_res.0.25"
  percent.mito: 0.10
  cell.source: "human"
  harmonize: FALSE
  sample.names: !r c("WA_MC_1","WA_MC_2","WA_MC_3","WA_MC_4","WA_MC_5","WA_MC_6","WA_MC_7","WA_MC_8","WA_MC_9","WA_MC_10","WA_MC_11","WA_MC_12","WA_MC_13","WA_MC_14","WA_MC_15","WA_MC_16")
---


```{r setup, include=FALSE, cache=FALSE}
library(future)
# plan("multiprocess", workers = 8)
options(future.globals.maxSize = 8000 * 1024^2)

ifelse(dir.exists("/mnt/scc/project_workspace/"),
       cremwd <- "/mnt/scc/",
       cremwd <- "/restricted/projectnb/crem-bioinfo/")
master_path <- file.path(cremwd, "project_workspace/25_07_03_Carly/calculations/")
prefix <- 'combined_harmony'
calculations_path <- paste0(master_path, prefix, "/")
plots_path <- file.path(calculations_path, "plots/")
rds_path <- file.path(calculations_path, "rds/")
cache_path <- file.path(calculations_path, "cache/") # it must end in a slash
dir.create(rds_path, recursive = T)
dir.create(plots_path, recursive = T)

knitr::opts_chunk$set(echo = FALSE, message = FALSE,error = FALSE,warning = FALSE, cache = TRUE, cache.path = cache_path, fig.width=9,fig.height=7, autodep=TRUE, collapse = FALSE, fig.path = plots_path, fig.keep = "all", comment = "##", dev = c("png", "pdf"), cache.lazy = FALSE)   
options(tibble.print_max = 150)

library(tidyverse)
library(Seurat)
library(Matrix)
library(matrixStats) #rowVars
library(magrittr)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(data.table) # getting counts
library(knitr)
library(clustree)
library(patchwork)
library(harmony)
```


```{r load_objects, eval=FALSE}
sc <- readRDS(paste0(rds_path, "sc.Rds"))
```

```{r load_and_merge_from_scratch, eval=T}

seu.list <- list()
sample.names <- params$sample.names
for (i in 1:length(sample.names)) {
  seu.list[[i]] <- readRDS(paste0(master_path,"/analysis/", sample.names[i], "/rds/sc.Rds"))
 #seu.list[[i]] <- UpdateSeuratObject(seu.list[[i]])
  seu.list[[i]]@project.name <- sample.names[i]
  #seu.list[[i]]$orig.ident <- sub("KD_AA_0304_", "", seu.list[[i]]$orig.ident)
  DefaultAssay(seu.list[[i]]) <- "RNA" # make default RNA, so that SCT can be removed
  seu.list[[i]] <- DietSeurat(seu.list[[i]], counts = TRUE, scale.data = FALSE, assays = "RNA")
}
sc <- merge(seu.list[[1]], y = seu.list[-1], project = "sc")
#sc$annot <- paste0(sc$orig.ident, "_EPCAM_", sc$EPCAM_state)
```

```{r loadsample, eval=FALSE}
sc1=readRDS("/restricted/projectnb/crem-bioinfo/project_workspace/24_03_14_andrea/calculations/analysis/combined_without_D63Tplus/rds/sc.update.ER.Rds")
Idents(sc1)="orig.ident"
sc=subset(sc1,idents=c("D17Tplus","D26Tplus","D26Tminus"))
```

# QC filtering

```{r load_sc_qc, fig.height=4}
#cat("UMI counts per cell")
#summary(apply(GetAssayData(sc, slot = "counts"), 2, sum))
#cat("UMI counts per gene")
#summary(apply(GetAssayData(sc, slot = "counts"), 1, sum))

sc$orig.ident2 <- sc$orig.ident # store for future reference

sc$orig.ident <- plyr::mapvalues(
  sc$orig.ident,
  c(
    "WA_MC_1", "WA_MC_2", "WA_MC_3", "WA_MC_4", "WA_MC_5", "WA_MC_6",
    "WA_MC_7", "WA_MC_8", "WA_MC_9", "WA_MC_10", "WA_MC_11", "WA_MC_12",
    "WA_MC_13", "WA_MC_14", "WA_MC_15", "WA_MC_16"
  ),
  c(
    "wt_1",   # WA_MC_1
    "M_2",    # WA_MC_2
    "wt_3",   # WA_MC_3
    "wt_4",   # WA_MC_4
    "wt_5",   # WA_MC_5
    "M_6",    # WA_MC_6
    "M_7",    # WA_MC_7
    "M_8",    # WA_MC_8
    "Z_9",    # WA_MC_9
    "Z_10",   # WA_MC_10
    "M_11",   # WA_MC_11
    "M_12",   # WA_MC_12
    "Z_13",   # WA_MC_13
    "Z_14",   # WA_MC_14
    "wt_15",  # WA_MC_15
    "wt_16"   # WA_MC_16
  )
)

Idents(sc) <- "orig.ident"

cat("After filtering doublets and degraded cells")
p <- VlnPlot(sc, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), pt.size = 0.1) 
p <- p & ggmin::theme_powerpoint() & theme(axis.title.x = element_blank()) & NoLegend() & RotatedAxis()
p
ggsave(paste0(plots_path, "Vln.qc.after.pdf"), height = 4, width = 5)
sc


#p <- VlnPlot(sc, features = c("TBX4", "TBX5", "FOXF1", "PTCH1", "GLI1", "WNT2","MSC", "WNT4","WT1","KDR","HAND1","PRRX1"),stack = TRUE,flip = TRUE, pt.size = 0.1) 
#p <- p & ggmin::theme_powerpoint() & theme(axis.title.x = element_blank()) & NoLegend() & RotatedAxis()
#p
#ggsave(paste0(plots_path, "Vln.qc.after.pdf"))


#p <- Stacked_VlnPlot(seurat_object = sc, features = c("TBX4", "TBX5", "FOXF1", "PTCH1", "GLI1", "WNT2","MSC", "WNT4","WT1","KDR","HAND1","PRRX1"), x_lab_rotate = TRUE)

#ncols=c('#F8766D','#F8766D','#F8766D','#1F78B4','#1F78B4','#1F78B4','#1F78B4')

```

```{r interesting_genes}
interesting_genes <- c(
  "NKX2-1", "EGFP-EXTRA", "TDTOMATO_EXTRA_IVS", "MCHERRY-FRT", "SFTA3", "SFTPB", "SOX2",      
  "AFP", "ALB",
  "TFF1", # gut/gastric
  "CDX2", # intestinal
  "SCGB3A2", # type 2 cells
  "TOP2A", "AURKB", "MKI67", "BIRC5", # cell cycle
  "TP63", "KRT5",
  "SCGB1A1",
  "SFTPC", "TFF2",
  "SOX9",
  "HP",
  "FOXJ1",
  "BMP3", "FOXP2", "CPM", "FGF9",
  "NKD1",
  "GIF", "CLDN18", "MUC6",
  "TF", "APOA1", "CYP4F3", "CYP3A7",
  "PAX9", "KRT14",
  "SFTA2", "AQP4",
  "AXIN2",
  "CFTR",
  "FOXI1", "ASLC3")
firstup <- function(x) {
  x <- tolower(x)
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}
if(params$cell.source == "mouse") { interesting_genes <- c(firstup(interesting_genes), "GFP", "TDTOMATO","MCHERRY-FRT","LACZ") }
cat("Pre-selected genes: ", interesting_genes)
interesting_genes <- interesting_genes[interesting_genes %in% rownames(sc)]
cat("Pre-selected genes expressed in current dataset: ", interesting_genes)
```

# Dimensionality reduction

Regressing out the confounding effect of cell degradation (by modeling the mitochondrial percentage as a latent variable).

```{r dim_red_pca}
sc <- SCTransform(sc, vars.to.regress=c("percent.mito","percent.mt"), verbose = FALSE) %>% RunPCA(verbose = FALSE)
ElbowPlot(sc, 50)
#ggsave(paste0(plots_path, "elbow.pdf"))

if(params$harmonize) {
  sc <- RunHarmony(sc, assay.use = "SCT", group.by.vars = "orig.ident")
  p1 <- DimPlot(sc, reduction = "pca", group.by = "orig.ident")
  p2 <- DimPlot(sc, reduction = "harmony", group.by = "orig.ident")
  p <- p1 + p2 & ggmin::theme_powerpoint() & NoAxes()
  print(x = sc[['harmony']], dims = 1:5, nfeatures = 5, projected = FALSE)
} else {
  p <- DimPlot(sc, reduction = "pca", group.by = "orig.ident") & ggmin::theme_powerpoint() & NoAxes()
  print(x = sc[['pca']], dims = 1:5, nfeatures = 5, projected = FALSE)
}
p
```

These are the genes driving the first 9 principal components

```{r dim_heatmap, fig.height=11}
if(params$harmonize) {
  DimHeatmap(sc, reduction = "harmony", dims = 1:9, cells = 500, balanced = TRUE)
  } else {
  DimHeatmap(sc, dims = 1:9, cells = 500, balanced = TRUE)
}
```

# Clustering

Use UMAP for non-linear dimensionality reduction

Use Louvain algorithm for community detection.

```{r cluster_and_rdim, eval=TRUE, results=FALSE}
if(params$harmonize) {
  sc <- FindNeighbors(sc , reduction = "harmony", dims = 1:40, graph.name = "Harmony")        
  sc <- FindClusters(sc, resolution = seq(1.5, 0.25, -0.25), graph.name = "Harmony") # reverse order, seurat_clusters takes last run's value
  sc <- FindClusters(sc, resolution = seq(0.20, 0.05, -0.05), graph.name = "Harmony") # reverse order, seurat_clusters takes last run's value
  sc <- RunUMAP(sc, reduction = "harmony", dims = 1:40)
  } else {
  sc <- FindNeighbors(sc, dims = 1:30)
  sc <- FindClusters(sc, resolution = seq(0.20, 0.05, -0.05)) # reverse order, seurat_clusters takes last run's value
  sc <- FindClusters(sc, resolution = seq(1.5, 0.25, -0.25)) # reverse order, seurat_clusters takes last run's value
  sc <- RunUMAP(sc, dims = 1:30)
}

```

Non-linear dimensionality reduction with UMAP

```{r plot_rdim}
DimPlot(sc, group.by = "orig.ident") + ggmin::theme_powerpoint()
#ggsave(paste0(plots_path, "UMAP.color.by.orig.ident.pdf"), width = 8, height = 7)
```


# Cell-cycle stage classification

Score G1, G2/M and S signatures in each cell.

Classify phase based on that score.

```{r CC_regression, eval=TRUE}
if(params$cell.source == "human") {
  s.genes <- cc.genes.updated.2019$s.genes
  g2m.genes <- cc.genes.updated.2019$g2m.genes
} else {
  s.genes <- firstup(cc.genes.updated.2019$s.genes)
  g2m.genes <- firstup(cc.genes.updated.2019$g2m.genes)
}
sc <- CellCycleScoring(sc, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)  
grouping <- "Phase"; DimPlot(sc, reduction = "umap", group.by =  grouping) + ggmin::theme_powerpoint()

kable(table(sc$Phase, sc[[params$resDEG]][[1]]), caption="Cell cycle stage classification per 
cluster") %>%   kable_styling() %>%   scroll_box(width = "100%", height = "200px")
```

# Molecular Signatures scoring

Compute enrichment for molecular signatures using method from Tirosh et al, Science (2016)    

```{r mol_sig, fig.height=11, eval=FALSE}
msig <- scan(paste0(cremwd, "/reference_data/gene_sets/lung.matur.differ.MSig.txt"), what="", sep="\n") # Read in the data
msig <- sapply(msig, function(k) gsub(",$", "", k))
msig <- strsplit(msig, ",[[:space:]]+")  # Separate elements by a comma and one or more whitepace
names(msig) <- sapply(msig, `[[`, 1)  # subset the first vector element and set it as the list element name
msig <- lapply(msig, `[`, -1) # Remove the first vector element from each list element        
sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/19_09_10_darrell_habermann/calculations/analysis/habermann//rds/sc.markers.wilcox.celltype.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Hb_", sc.markers.wilcox.res[[2]]$cluster)  # habermann et al msig

msig2 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)

msig3 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea.msig.xlsx"), sheet=1))
msig3 <- lapply(msig3, function(x) x[!is.na(x)])

msig5 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea_ER_Genesets.xlsx"), sheet=1))
msig5 <- lapply(msig5, function(x) x[!is.na(x)])
msig5 <- msig5[-1]
names(msig5) <- paste0('ER_', names(msig5))

msig6 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/EarlyFibro_minusCC.xlsx"), sheet=1))
msig6 <- lapply(msig6, function(x) x[!is.na(x)])


msig <- c(msig, msig2)

genes <- c('COL1A1','ACTA2','FN1','CTHRC1','CTGF')
msig[[36]] <- genes
names(msig)[36] <- "Fibrotic_markers"

sc.markers.res <- as.list(readxl::read_excel(paste0(cremwd, "project_workspace/23_09_11_andrea/calculations/analysis/combined/TopMarkers_celltype_level3.xls")))
msig4 <- split(sc.markers.res$feature, sc.markers.res$group)

msig <- c(msig)

sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/24_03_14_andrea/calculations/analysis/combined_without_D63Tplus/rds/sc.markers.mas.subset.01.SCT_snn_res.0.5.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Top50_Cluster_", sc.markers.wilcox.res[[2]]$cluster)
msig7 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)

msig7[['Top50_Cluster_4_subset']] <- c('H19','ACTG1','SFRP2','SULT1E1','GABPB1-AS1','AC024940.2','NAP1L1','CCND2','DES','BCL11A','MT-TP','IGF2BP2','SNAI2','SLITRK6','MAGED2','UNC5C','NRP2','BCAT1','NKAIN4','PCDH18','MME','TNFRSF19','CTSC','GNAO1','PLAC9','L1TD1','SCN7A','FN1','HIPK2')


names(msig) <- sub("\\+", "pos", names(msig))
names(msig) <- sub("-", "neg", names(msig))
names(msig) <- make.names(names(msig))
if(params$cell.source == "mouse") {
    msig <- lapply(msig, firstup)
}



sc <- AddModuleScore(sc, features = msig, name = names(msig), search = T)
sc <- AddMetaData(sc, sc[[paste0(names(msig), 1:length(names(msig)))]], col.name = names(msig))
for(i in paste0(names(msig), 1:length(names(msig)))) {
  sc[[i]] <- NULL
}
```


```{r mol_sig_score, fig.height=11, eval=T}
msig <- scan(paste0(cremwd, "/reference_data/gene_sets/lung.matur.differ.MSig.txt"), what="", sep="\n") # Read in the data
msig <- sapply(msig, function(k) gsub(",$", "", k))
msig <- strsplit(msig, ",[[:space:]]+")  # Separate elements by a comma and one or more whitepace
names(msig) <- sapply(msig, `[[`, 1)  # subset the first vector element and set it as the list element name
msig <- lapply(msig, `[`, -1) # Remove the first vector element from each list element        
sc.markers.wilcox.res <- readRDS(paste0(cremwd, "project_workspace/19_09_10_darrell_habermann/calculations/analysis/habermann//rds/sc.markers.wilcox.celltype.Rds"))
sc.markers.wilcox.res[[2]]$cluster <- paste0("Hb_", sc.markers.wilcox.res[[2]]$cluster)  # habermann et al msig
msig2 <- split(sc.markers.wilcox.res[[2]]$gene, sc.markers.wilcox.res[[2]]$cluster)
#msig3 <- as.list(readxl::read_excel(paste0(cremwd, "/reference_data/gene_sets/andrea.msig.xlsx"), sheet=1))
#msig3 <- lapply(msig3, function(x) x[!is.na(x)])

msig <- c(msig, msig2)

#genes <- c('COL1A1','ACTA2','FN1','CTHRC1','CTGF')
#msig[[51]] <- genes
#names(msig)[51] <- "Fibrotic_markers"

#sc.markers.res <- as.list(readxl::read_excel(paste0(cremwd, "project_workspace/23_09_11_andrea/calculations/analysis/combined/TopMarkers_celltype_level3.xls")))
#msig4 <- split(sc.markers.res$feature, sc.markers.res$group)

#msig <- c(msig)
#msig <- msig[c(-3,-4)]
#msig <- msig[-1]
#msig <- msig[-70]

names(msig) <- sub("\\+", "pos", names(msig))
names(msig) <- sub("-", "neg", names(msig))
names(msig) <- make.names(names(msig))
if(params$cell.source == "mouse") {
    msig <- lapply(msig, firstup)
}



sc <- AddModuleScore(sc, features = msig, name = names(msig), search = T, nbin = 10,ctrl = 10)
sc <- AddMetaData(sc, sc[[paste0(names(msig), 1:length(names(msig)))]], col.name = names(msig))
for(i in paste0(names(msig), 1:length(names(msig)))) {
  sc[[i]] <- NULL
}
```


# UMAP clusters

```{r facetted_louvain_clusters_UMAP, fig.height=6}
if(params$harmonize) {
  grouping <- "Harmony_res.0.1";  p1 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.15"; p2 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.2";  p3 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.25"; p4 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.5";  p5 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "Harmony_res.0.75"; p6 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  } else {
  grouping <- "SCT_snn_res.0.1";  p1 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.15"; p2 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.2";  p3 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.25"; p4 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.5";  p5 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
  grouping <- "SCT_snn_res.0.75"; p6 <- DimPlot(sc, group.by = grouping, label = T) + labs(title = grouping)
}
p <- p1 + p2 + p3 + p4 + p5 + p6
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
p
ggsave(paste0(plots_path, "UMAP.clust.pdf"), width = 10, height = 7)
```

# UMAP pre-selected features

```{r echo=FALSE}
# 4 columns, 9 width, height per line == 9 / 4 == 2.25
x <- interesting_feats <- c("nFeature_RNA", "nCount_RNA", "percent.mito", names(msig), interesting_genes)
len <- (length(unique(x))/4)*2.25
```

```{r pre_selected_marker_genes_UMAP,  fig.height=len}
interesting_feats <- c("nFeature_RNA", "nCount_RNA", "percent.mito", names(msig), interesting_genes)
p <- FeaturePlot(sc, features = interesting_feats, cols = c("#f0f0f0", brewer.pal(9,"OrRd")))
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
p
ggsave(paste0(plots_path, "UMAP.preselected.feats.pdf"),limitsize = FALSE)
```


# Differential expression

Differential expression model: MAST, Finak et al.:
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0844-5

For a recent comparison on the performance of different methods for single-cell differential expression, see:
https://www.nature.com/articles/nmeth.4612


```{r use_seurat, eval=F, fig.height=15}
fmas <- function(sc, res) {
    Idents(sc) <- res
    file_out <- paste0(calculations_path, "DEG.SCT_snn_res.0.5.subset.0.1.3.4.8.9.10.13.xlsx")
    seurat.markers <- FindAllMarkers(sc, test.use = "MAST", only.pos = TRUE, min.pct = 0.1, verbose = F)
    seurat.markers.summary <- as.data.frame(seurat.markers %>% group_by(cluster) %>% dplyr::filter(p_val_adj < 0.05) %>% top_n(50, abs(avg_log2FC)))
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = F)
    return(list(all = seurat.markers, top = seurat.markers.summary))
}
resDEG <- 'SCT_snn_res.0.5'
sc.markers.mas.res <- fmas(sc.2, resDEG)

saveRDS(sc.markers.mas.res, paste0(rds_path, "sc.markers.mas.subset.01.", resDEG, ".Rds"))
```

Table of top 20 DEG per cluster


```{r, eval=F}
sc.markers.mas.res[[2]] %>% dplyr::mutate(cluster = cell_spec(
    cluster, color = "white", bold = T,
    background = spec_color(as.numeric(factor(cluster)), end = 0.9, direction = -1)
  )) %>% kable(escape = F, caption=paste0("Top DEG for clusters at ", resDEG )) %>% kable_styling() %>% scroll_box(width = "100%", height = "600px")
```

# Heatmap of DEG

Heatmap of top 20 DEG per cluster


```{r heatmap_DEG, eval = F, fig.height=15}
Idents(sc.2) <- resDEG
# switch to RNA normalized for heatmap visualization
DefaultAssay(sc.2) <- "RNA"
sc.2 <- NormalizeData(sc.2)
all.genes <- rownames(sc.2)
sc.2 <- ScaleData(sc.2, features = all.genes, vars.to.regress="percent.mito", verbose = F) # default: only scales var.genes, which misses some in heatmap

g <- DoHeatmap(sc.2, features = sc.markers.mas.res[[2]]$gene) + scale_fill_gradientn(colors = c("blue", "white", "red"))
print(g)
ggsave(paste0(plots_path, "heatmap.Top50.359.vs.364.pdf"), width = 10, height = 20, limitsize = FALSE)# only need to use print if you aren't in a top-level statement (e.g. in a function, in an if/else block, etc.)
DefaultAssay(sc) <- "SCT"

```

```{r save_object}
saveRDS(sc, paste0(rds_path, "sc.Rds"))
```

# UMAP of DEG


```{r echo=FALSE, eval=FALSE}
# 4 columns, 9 width, height per line == 9 / 4 == 2.25
x <- sc.markers.mas.res[[1]] %>% group_by(cluster) %>% dplyr::filter(p_val_adj < 0.05) %>% top_n(4, avg_log2FC) %>% pull(gene)
len2 <- (length(unique(x))/4)*2.25
```

```{r feat_DEG_UMAP, error = TRUE, eval=FALSE}
# when allowing duplicates gives error
p <- FeaturePlot(sc, features = unique(x), cols = c("#f0f0f0", brewer.pal(9,"OrRd")) )        
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
p
ggsave(paste0(plots_path, "UMAP.DEG.pdf"))
```

```{r export_spring, eval=T}
 #sc_harmony <- readRDS("/restricted/projectnb/crem-bioinfo/project_workspace/20_09_25_andrea/calculations/analysis/combined_harmony/rds/sc.Rds")
 #harmony_clus <- sc_harmony[[]][grep("Harmony", names(sc_harmony[[]]))]
 #sc <- AddMetaData(sc, harmony_clus)
 #meta.subset <- sc[[c("orig.ident", "Phase", grep("^SCT", colnames(sc[[]]), value = T), grep("^Harmony", colnames(sc[[]]), value = T) )]]

export.data <- GetAssayData(sc, slot = "counts")  # for SCT, counts are corrected for depth   
export.genes <- rownames(sc)
write.table(as.matrix(export.data), gzfile(paste0(master_path, "/subset.spring.data.tsv.gz")), sep = "\t", quote = F, col.names = T, row.names = T )
write.table(export.genes, paste0(master_path, "/subset.spring.genes.tsv"), sep = "\t", quote = F, col.names = F, row.names = F )
if(params$harmonize) {
  meta.subset <- sc[[c("orig.ident", "Phase", grep("^Harmony", colnames(sc[[]]), value = T) )]]
  } else {
  meta.subset <- sc[[c("orig.ident", "Phase", grep("^SCT", colnames(sc[[]]), value = T) )]]   
}
groupings <- t(meta.subset) # select metadata
meta.continuous <- sc[[names(msig)]]
custom.color.tracks <- t(meta.continuous)
write.table(custom.color.tracks, paste0(master_path, "/subset.spring.custom.color.tracks.csv"), sep = ",", quote = F, col.names = F, row.names = T )
write.table(groupings, paste0(master_path, "/subset.spring.groupings.csv"), sep = ",", quote = F, col.names = F, row.names = T )
```

```{r featureplot, eval=FALSE}
genes <- c("Top50_Cluster_1","Top50_Cluster_0","Top50_Cluster_3","Top50_Cluster_4")
data <- FetchData(sc, vars = c("UMAP_1", "UMAP_2", genes))

global_min <- min(data[, genes])
global_max <- max(data[, genes])

#color_scale <- colorRampPalette(brewer.pal(9, "OrRd"))(100)
color_scale <- c("#4575B4","#74ADD1","#ABD9E9","#E0F3F8","#FFFFBF","#FEE090","#FDAE61","#F46D43","#D73027")[c(1,1:9,9)]
plots <- lapply(genes, function(gene) {
     ggplot(data, aes_string(x = "UMAP_1", y = "UMAP_2", color = gene)) +
         geom_point(size = 0.5) +
         scale_color_gradientn(colors = color_scale, limits = c(global_min, global_max)) +
         theme_void() +
         ggtitle(gene)
})
wrap_plots(plots)

```

```{r metadata, eval=FALSE}
sc$experiment <- sub("_.*$", "",sc$orig.ident)
p <- DimPlot(sc, group.by = "experiment") + ggmin::theme_powerpoint()
ggsave(paste0(plots_path, "UMAP.color.by.experiment.pdf"), p, width = 8, height = 7)
saveRDS(sc, paste0(rds_path, "sc.Rds"))
```

# Azimuth

```{r annotate, eval=FALSE}
# Seurat 5.3.0 had bugs affecting Azimuth transfer anchors function
# update to 5.3.1 or downgrade to 5.2.x
devtools::install_github("satijalab/seurat") # main is 5.3.1, bug fixed already
# remotes::install_version("Seurat", "5.2.1")
library(Azimuth)
library(SeuratData)

# Load your query Seurat object (replace "query.rds")
sc

# ref <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/ref.Rds")

# # Choose your reference (for example, use PBMC reference)
# reference <- Azimuth::LoadReference("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/")
# sc_test <- JoinLayers(sc, assay = "RNA") # Fix to bug: https://github.com/satijalab/seurat/issues/8368
# 
# # Check if these common genes are present in the query dataset's RNA assay
# common_ref_genes <- readRDS(paste0(dir_ref, "ref_genes.Rds"))
# common_in_query <- common_ref_genes[common_ref_genes %in% rownames(sc[["SCT"]])]
# # Output missing genes (if any)
# missing_genes <- common_ref_genes[!common_in_query]
# if (length(missing_genes) > 0) {
#   print(paste("Missing genes in query data:", paste(missing_genes, collapse = ", ")))
# } else {
#   print("All features are present in query data.")
# }
# 
# 
# sc_annot <- RunAzimuth(query = sc_test, reference = "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/",
#                        assay = "SCT",
#                        annotation.levels = "Main_cell_type",
#                        umap.name = "refUMAP")
# sc_annot_hs <- RunAzimuth(sc, reference = "lungref")

```

## Run - tested OK

```{r}
query <- sc
assay <- "SCT"
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"

reference <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"
reference <- LoadReference(reference)$map
dims <- as.double(slot(reference, "neighbors")$refdr.annoy.neighbors@alg.info$ndim)
reference.version <- ReferenceVersion(reference)
azimuth.version <- as.character(packageVersion(pkg = "Azimuth"))
seurat.version <- as.character(packageVersion(pkg = "Seurat"))
meta.data <- names(slot(reference, "meta.data"))
annotation.levels <- names(slot(object = reference, name = "meta.data"))
annotation.levels <- annotation.levels[!grepl(pattern = "^nCount", x = annotation.levels)]
annotation.levels <- annotation.levels[!grepl(pattern = "^nFeature", x = annotation.levels)]
annotation.levels <- annotation.levels[!grepl(pattern = "^ori", x = annotation.levels)]
# query <- ConvertGeneNames(
#       object = query,
#       reference.names = rownames(x = reference),
#       homolog.table = 'https://seurat.nygenome.org/azimuth/references/homologs.rds'
#     )
# Calculate nCount_RNA and nFeature_RNA if the query does not
# contain them already
if (!all(c("nCount_RNA", "nFeature_RNA") %in% c(colnames(x = query[[]])))) {
  calcn <- as.data.frame(x = Seurat:::CalcN(object = query[[assay]]))
  colnames(x = calcn) <- paste(colnames(x = calcn), assay, sep = '_')
  query <- AddMetaData(object = query, metadata = calcn)
  rm(calcn)
}

# Calculate percent mitochondrial genes if the query contains genes
# matching the regular expression "^MT-"
if (any(grepl(pattern = '^mt-', x = rownames(x = query)))) {
  query <- PercentageFeatureSet(
    object = query,
    pattern = '^mt-',
    col.name = 'percent.mt',
    assay = assay
  )
}

umap.name = "ref.umap"
do.adt = FALSE
verbose = TRUE
assay = NULL
k.weight = 50
n.trees = 20
mapping.score.k = 100
#    features = rownames(Loadings(reference[["refDR"]]))

query <- JoinLayers(query, assay = "RNA")
common_ref_genes <- readRDS(paste0(dir_ref, "ref_genes.Rds"))
common_in_query <- common_ref_genes[common_ref_genes %in% rownames(sc[["SCT"]])] # See: https://github.com/satijalab/seurat/issues/4019

# Find anchors between query and reference
anchors <- FindTransferAnchors(
  reference = reference,
  query = query,
  k.filter = NA,
  reference.neighbors = "refdr.annoy.neighbors",
  reference.assay = "refAssay",
  query.assay = assay,
  reference.reduction = "refDR",
  normalization.method = "SCT",
  features = common_in_query,
  dims = 1:dims,
  n.trees = n.trees,
  mapping.score.k = mapping.score.k,
  verbose = verbose
)
# Transferred labels are in metadata columns named "predicted.*"
# The maximum prediction score is in a metadata column named "predicted.*.score"
# The prediction scores for each class are in an assay named "prediction.score.*"
# The imputed assay is named "impADT" if computed
refdata <- lapply(X = annotation.levels, function(x) {
  reference[[x, drop = TRUE]]
})
names(x = refdata) <- annotation.levels


query <- TransferData(
  reference = reference,
  query = query,
  query.assay = assay,
  dims = 1:dims,
  anchorset = anchors,
  refdata = refdata,
  n.trees = 20,
  store.weights = TRUE,
  k.weight = k.weight,
  verbose = verbose
)
# Calculate the embeddings of the query data on the reference SPCA
query <- IntegrateEmbeddings(
  anchorset = anchors,
  reference = reference,
  query = query,
  query.assay = assay,
  reductions = "pcaproject",
  reuse.weights.matrix = TRUE,
  verbose = verbose
)
#     # Calculate the query neighbors in the reference
#     # with respect to the integrated embeddings
query[["query_ref.nn"]] <- FindNeighbors(
  object = Embeddings(reference[["refDR"]])[,1:ncol(Embeddings(query[["integrated_dr"]]))],
  query = Embeddings(query[["integrated_dr"]]),
  return.neighbor = TRUE,
  l2.norm = TRUE,
  verbose = verbose
)
#     # Error: fv.size() != vector_size. See: https://github.com/satijalab/seurat/issues/4019
#     # The reference used in the app is downsampled compared to the reference on which
#     # the UMAP model was computed. This step, using the helper function NNTransform,
#     # corrects the Neighbors to account for the downsampling.
#     query <- NNTransform(
#       object = query,
#       meta.data = reference[[]]
#     )
#     #Error in NNTransform(object = query, meta.data = reference[[]]) : 
# #   could not find function "NNTransform"
#   
#     # Project the query to the reference UMAP.
query[[umap.name]] <- RunUMAP(
  object = query[["query_ref.nn"]],
  reduction.model = reference[["refUMAP"]],
  reduction.key = 'UMAP_',
  verbose = verbose
)
# Calculate mapping score and add to metadata
query <- AddMetaData(
  object = query,
  metadata = MappingScore(anchors = anchors, ndim = dims),
  col.name = "mapping.score"
)

saveRDS(query, paste0(rds_path, "sc.Rds"))

```

## EDA Azimuth rst

```{r}
query[[]] %>%
    group_by(predicted.Main_cell_type, experiment) %>%
    dplyr::summarize(Mean.pred = mean(predicted.Main_cell_type.score, na.rm=TRUE),
                     Mean.map = mean(mapping.score, na.rm=TRUE)
                     )

table(query[[]]$annot_supervised, query[[]]$predicted.Main_cell_type)
table(query[[]]$predicted.Main_cell_type, query[[]]$annot_supervised)

grouping <- "predicted.Main_cell_type"
p1 <- DimPlot(query, group.by = grouping, label = T) + labs(title = grouping)
p1 <- p1 & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
ggsave(paste0(plots_path, "UMAP.Azimuth.pdf"), p1, width = 10, height = 10)
View(head(query[[]]))
grouping <- "predicted.Lineage"
p2 <- DimPlot(query, group.by = grouping, label = T) + labs(title = grouping)
p2 <- p2 & ggmin::theme_powerpoint() & NoAxes() & NoLegend()
ggsave(paste0(plots_path, "UMAP.Lineage.pdf"), p2, width = 10, height = 10)

p <- p1 + p2
ggsave(paste0(plots_path, "UMAP.both_annot.pdf"), p, width = 20, height = 10)


interesting_feats <- c("predicted.Main_cell_type.score", "mapping.score")
p <- FeaturePlot(query, features = interesting_feats) & scale_color_viridis_c(option = "viridis")
p <- p & ggmin::theme_powerpoint() & NoAxes() & NoLegend()

ggsave(paste0(plots_path, "UMAP.azimuth.scores.pdf"),p , width = 20, height = 10)
```


## Prep reference files


Required files for scRNAseq queries

File 1: ref.Rds Seurat object
Assay: 
SCTAssay named refAssay with a single SCTransform model stored in the SCTModel.list slot called "refmodel"

DimReducs
2 DimReduc: 
refUMAP
  misc slot of refUMAP containeds an element named "model":
  RunUMAP called with umap.method = "uwot", return.model = TRUE
and refDR 
  at least 50 dim
  associated with "refAssay" i.e. DefaultAssay(object[[“refDR”]]) returns "refAssay"

Neighbors
Neighbor object containing precomputed ref neighborhoods stored as refdr.annoy.neighbors. Computed of the refDR DimReduc using the first 50 dims

Tools
plotref
colormap

Metadata: any to be transfered to query and "ori.index"

File 2: index.annoy
GEnerated when computing refdr.annoy.neighbors


```{r, build_reference}
#!/usr/bin/env Rscript

# Script to build mouse pansci reference 1.0.0

# rule build_reference:
#     input:
#         script = "scripts/build_reference.R",
#         obj = "data/obj.rds",
#         annotations = "data/pansci_genenames.csv",
#     output:
#         ref = "reference/ref.Rds",
#         idx = "reference/idx.annoy",
#         obj = "full_reference.Rds"
#     shell:
#         """
#         Rscript {input.script} {input.obj} {input.genenames} {output.ref} {output.idx} {output.obj}
#         """

# Rscript {input.script} {input.counts} {input.genenames} {input.dr} {output.ref} {output.idx} {output.obj}

library(Azimuth)
library(glmGamPoi)

obj_original <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_filtered.rds")
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci/"
dir.create(dir_ref)
azimuth.reference <- paste0(dir_ref, "ref.Rds")
azimuth.index <- paste0(dir_ref, "idx.annoy")
# full.reference <- paste0(dir_ref, "pansci.Rds")
full.reference <- paste0(dir_ref, "pansci_subset.Rds")

colnames(obj_original[[]])
obj_original[[]] %>% dplyr::count(Organ_name, Main_cell_type, Lineage)
obj_original_sub <- subset(obj_original, Organ_name == "Lung")

# Convert gene IDs to gene symbols based on annotations file 
pansci.mtx <- LayerData(obj_original_sub, assay="RNA", layer="counts")
nonzero <- pansci.mtx > 0
keep_genes <- Matrix::rowSums(nonzero) >= 10; table(keep_genes)
obj_original_sub[["RNA"]][[]]$keep_genes <- keep_genes
gene_names <- obj_original_sub[["RNA"]][[]] %>% filter(keep_genes)
length(unique(gene_names$gene_name))
length(gene_names$gene_name)
length(unique(gene_names$gene_id))
length(gene_names$gene_id)

subset.pansci.mtx <- pansci.mtx[keep_genes, ]
dim(subset.pansci.mtx)
all(rownames(subset.pansci.mtx) == gene_names$gene_id)
rownames(subset.pansci.mtx) <- gene_names$gene_name
table(gene_names$gene_type)         
# Rebuild object from RNA assay and converted gene names
pansci.assay <- CreateAssayObject(counts = subset.pansci.mtx)

obj <- CreateSeuratObject(counts=pansci.assay, assay="RNA")
obj <- AddMetaData(obj, obj_original_sub[[]])
rownames(gene_names) <- rownames(obj)
obj[["RNA"]][[]] <- gene_names
dim(gene_names)
rownames(obj[["RNA"]])
obj[[]]
# Normalize with SCT
obj <- SCTransform(obj, vst.flavor = "v2", method = "glmGamPoi", verbose = TRUE)
saveRDS(obj, full.reference)

# Run PCA on the SCT residuals 
obj <- RunPCA(obj, assay = "SCT", reduction.name = "pca", npcs = 100)

# Build UMAP model 
obj <- RunUMAP(obj, dims = 1:50, return.model = T)

SCT_feats <- obj[["RNA"]][[]][ rownames(obj[["SCT"]][[]]) , ]
obj[["SCT"]][[]] <- SCT_feats
SCT_feats %>% dplyr::count(gene_type, sort = T)
saveRDS(obj, full.reference)
dim(obj[["SCT"]][[]])
obj$Main_cell_type <- droplevels(obj$Main_cell_type)
obj$Lineage <- droplevels(obj$Lineage)
mapping.ob <- obj
plotref <- obj[["umap"]]

set.seed(28)
ids <- sample(
  x = levels(as.factor(mapping.ob$Main_cell_type)),
  size = length(levels(as.factor(mapping.ob$Main_cell_type)))
)
colormap.ids <- scales::hue_pal()(n = length(x = ids))
names(x = colormap.ids) <- ids
colormap.ids <- colormap.ids[sort(x = names(x = colormap.ids))]

colormap <- list(
  Lineage = CreateColorMap(ids = unique(x = obj$Lineage)),
  Main_cell_type = colormap.ids
)


# Build Azimuth Reference
azimuth.obj <- AzimuthReference(obj,
                        refUMAP='umap',
                        refDR='pca',
                        refAssay = 'SCT',
                        plotref = plotref,
                        dims = 1:50,
                        k.param = 31,  
                        metadata = c("Main_cell_type", "Lineage"),
                        reference.version = "Lung_subset",
                        colormap = colormap
)
azimuth.obj[["SCT"]] <- azimuth.obj[["refAssay"]]
DefaultAssay(sc) <- "SCT"
ValidateAzimuthReference(object = azimuth.obj)

SaveAnnoyIndex(
  object = azimuth.obj[["refdr.annoy.neighbors"]],
  file = azimuth.index
)
saveRDS(
  object = azimuth.obj,
  file = azimuth.reference
)

azimuth.obj <- readRDS(azimuth.reference)
reference_pca_genes <- rownames(Loadings(azimuth.obj[["refDR"]]))
reference_rna_genes <- rownames(azimuth.obj[["refAssay"]])
common_ref_genes <- intersect(reference_pca_genes, reference_rna_genes)
saveRDS(common_ref_genes, paste0(dir_ref, "ref_genes.Rds"))



```

Full object test

```{r}
obj_original <- readRDS("/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_filtered.rds")
dir_ref <- "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_full/"
dir.create(dir_ref)
azimuth.reference <- paste0(dir_ref, "ref.Rds")
azimuth.index <- paste0(dir_ref, "idx.annoy")
# full.reference <- paste0(dir_ref, "pansci.Rds")
full.reference <- paste0(dir_ref, "pansci_full.Rds")

colnames(obj_original[[]])
obj_original[[]] %>% dplyr::count(Organ_name, Main_cell_type, Lineage)
# obj_original_sub <- subset(obj_original, Organ_name == "Lung")

# Convert gene IDs to gene symbols based on annotations file 
pansci.mtx <- LayerData(obj_original, assay="RNA", layer="counts")
nonzero <- pansci.mtx > 0
keep_genes <- Matrix::rowSums(nonzero) >= 10; table(keep_genes)
obj_original[["RNA"]][[]]$keep_genes <- keep_genes
gene_names <- obj_original[["RNA"]][[]] %>% filter(keep_genes)
length(unique(gene_names$gene_name))
length(gene_names$gene_name)
length(unique(gene_names$gene_id))
length(gene_names$gene_id)

subset.pansci.mtx <- pansci.mtx[keep_genes, ]
dim(subset.pansci.mtx)
all(rownames(subset.pansci.mtx) == gene_names$gene_id)
rownames(subset.pansci.mtx) <- gene_names$gene_name
table(gene_names$gene_type)         
# Rebuild object from RNA assay and converted gene names
pansci.assay <- CreateAssayObject(counts = subset.pansci.mtx)

obj <- CreateSeuratObject(counts=pansci.assay, assay="RNA")
obj <- AddMetaData(obj, obj_original[[]])
rm(obj_original)
rm(pansci.mtx)
rm(subset.pansci.mtx)
rm(pansci.assay)
gc()
rownames(gene_names) <- rownames(obj)
obj[["RNA"]][[]] <- gene_names
dim(gene_names)
rownames(obj[["RNA"]])
obj[[]]
# Normalize with SCT
obj <- SCTransform(obj, vst.flavor = "v2", method = "glmGamPoi", verbose = TRUE, conserve.memory = TRUE)
saveRDS(obj, full.reference)

# Run PCA on the SCT residuals 
obj <- RunPCA(obj, assay = "SCT", reduction.name = "pca", npcs = 50)

# Build UMAP model 
obj <- RunUMAP(obj, dims = 1:50, return.model = T)

SCT_feats <- obj[["RNA"]][[]][ rownames(obj[["SCT"]][[]]) , ]
obj[["SCT"]][[]] <- SCT_feats
SCT_feats %>% dplyr::count(gene_type, sort = T)
saveRDS(obj, full.reference)
obj <- readRDS(full.reference)

dim(obj[["SCT"]][[]])
# obj$Main_cell_type <- droplevels(obj$Main_cell_type)
# obj$Lineage <- droplevels(obj$Lineage)
mapping.ob <- obj
plotref <- obj[["umap"]]

set.seed(28)
ids <- sample(
  x = levels(as.factor(mapping.ob$Main_cell_type)),
  size = length(levels(as.factor(mapping.ob$Main_cell_type)))
)
colormap.ids <- scales::hue_pal()(n = length(x = ids))
names(x = colormap.ids) <- ids
colormap.ids <- colormap.ids[sort(x = names(x = colormap.ids))]



colormap <- list(
  Lineage = CreateColorMap(ids = unique(x = obj$Lineage)),
  Main_cell_type = colormap.ids,
  Organ_name = CreateColorMap(ids = unique(x = obj$Organ_name)),
  Sub_cell_type = CreateColorMap(ids = unique(x = obj$Sub_cell_type))
)


# Build Azimuth Reference
azimuth.obj <- AzimuthReference(obj,
                        refUMAP='umap',
                        refDR='pca',
                        refAssay = 'SCT',
                        plotref = plotref,
                        dims = 1:50,
                        k.param = 31,  
                        metadata = c("Main_cell_type", "Lineage", "Organ_name", "Sub_cell_type"),
                        reference.version = "Full_pansci",
                        colormap = colormap
)
azimuth.obj[["SCT"]] <- azimuth.obj[["refAssay"]]
DefaultAssay(sc) <- "SCT"
ValidateAzimuthReference(object = azimuth.obj)

SaveAnnoyIndex(
  object = azimuth.obj[["refdr.annoy.neighbors"]],
  file = azimuth.index
)
saveRDS(
  object = azimuth.obj,
  file = azimuth.reference
)

azimuth.obj <- readRDS(azimuth.reference)
reference_pca_genes <- rownames(Loadings(azimuth.obj[["refDR"]]))
reference_rna_genes <- rownames(azimuth.obj[["refAssay"]])
common_ref_genes <- intersect(reference_pca_genes, reference_rna_genes)
saveRDS(common_ref_genes, paste0(dir_ref, "ref_genes.Rds"))



```

# Carly email request

Cluster 0, 7, 9, 25, 26  = endothelial 
Cluster 1, 3, 4, 5, 6, 8, 12, 14, 17, 22, 27 = AT2 
Cluster 2 = fibroblasts
Cluster 10 = monocytes/macrophages
Cluster 15, 18, 20, 21, 23, 24 = ??? (could I get a list of top genes from each cluster, maybe that would help) 
Cluster 11 = ciliated 
Cluster 13 = B cells
Cluster 16 = T/NK cells
Cluster 19 = AT1 

   Cluster 0, 7, 9, 25, 26  = endothelial 
      Cluster 1, 3, 4, 5, 6, 8, 12, 14, 17, 22, 27 = AT2 
      Cluster 2, 15 = fibroblasts/myofibroblasts
      Cluster 10 = monocytes/macrophages
      Cluster 20, 23, 24 = unknown (tried to figure out what these are and I can't find anything, but there aren't many cells so I think let's leave them unannotated for now)
      Cluster 11 = ciliated 
      Cluster 13 = B cells
      Cluster 16 = T/NK cells
      Cluster 18= Club cells
      Cluster 19 = AT1 
      Cluster 21 = Basal cells
      
Once these are annotated, can we cluster out the AT2s and do DEG between Z and wild type AT2s and Z and M AT2s and M and wild type? 

```{r feedback_DEG, eval=FALSE}
all(sc$seurat_clusters == sc$SCT_snn_res.0.25) # TRUE
sc$annot_supervised <- fct_recode(sc$seurat_clusters,
            "endothelial"    = "0",
            "AT2"            = "1",
            "fibroblasts"    = "2",
            "AT2"            = "3",
            "AT2"            = "4",
            "AT2"            = "5",
            "AT2"            = "6",
            "endothelial"    = "7",
            "AT2"            = "8",
            "endothelial"    = "9",
            "monocytes/macrophages" = "10",
            "ciliated"       = "11",
            "AT2"            = "12",
            "B cells"        = "13",
            "AT2"            = "14",
            "fibroblasts"   = "15",
            "T/NK cells"     = "16",
            "AT2"            = "17",
            "club cells"   = "18",
            "AT1"            = "19",
            "undetermined"   = "20",
            "basal cells"   = "21",
            "AT2"            = "22",
            "undetermined"   = "23",
            "undetermined"   = "24",
            "endothelial"    = "25",
            "endothelial"    = "26",
            "AT2"            = "27"
)
Idents(sc) <- "annot_supervised"
table(sc$annot_supervised, sc$seurat_clusters)
sc_subset <- subset(sc, idents = "AT2")
DefaultAssay(sc_subset) <- "RNA"
sc_subset <- DietSeurat(sc_subset, counts = TRUE, scale.data = FALSE, assays = "RNA")
sc_subset <- SCTransform(sc_subset, vars.to.regress="percent.mito", verbose = FALSE) %>% RunPCA(verbose = FALSE)
sc_subset <- FindNeighbors(sc_subset, dims = 1:30)
for(i in grep("^SCT", names(sc_subset[[]]), value = T)) {
  sc_subset[[i]] <- NULL
}
sc_subset[["seurat_clusters"]] <- NULL
sc_subset <- FindClusters(sc_subset, resolution = seq(0.20, 0.05, -0.05)) # reverse order, seurat_clusters takes last run's value
sc_subset <- FindClusters(sc_subset, resolution = seq(1.5, 0.25, -0.25)) # reverse order, seurat_clusters takes last run's value
sc_subset$SCT_snn_res.0.05
sc_subset <- RunUMAP(sc_subset, dims = 1:30)
DimPlot(sc_subset, group.by = "SCT_snn_res.0.05") + ggmin::theme_powerpoint()
# Proportion plot for SCT_snn_res.0.05
FeaturePlot(sc_subset, features = c("Lyz1", "Aqp5","Sftpc", "Cdkn1a", "Krt8"))
# recluster AT2s and do DEG between Z and wild type AT2s and Z and M AT2s and M and wild type

saveRDS(sc_subset, paste0(rds_path, "sc_subset.AT2.Rds"))
sc_subset <- readRDS(paste0(rds_path, "sc_subset.AT2.Rds"))

scCustomize::Proportion_Plot(sc_subset, plot_type = "bar",  plot_scale = "percent",  group_by_var = "experiment", split.by = "SCT_snn_res.0.05")


fmas <- function(sc, res) {
    Idents(sc) <- res
    file_out <- paste0(calculations_path, "DEG.AT2subset.", res, ".xlsx")
    seurat.markers <- FindAllMarkers(sc, test.use = "MAST", only.pos = TRUE, min.pct = 0.1, verbose = F)
    seurat.markers.summary <- as.data.frame(seurat.markers %>% group_by(cluster) %>% dplyr::filter(p_val_adj < 0.05) %>% top_n(50, abs(avg_log2FC)))
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = F)
    return(list(all = seurat.markers, top = seurat.markers.summary))
}

fmas_includesNeg <- function(sc, res) {
    Idents(sc) <- res
    file_out <- paste0(calculations_path, "DEG.AT2subset.includesNegativeMarkers.", res, ".xlsx")
    seurat.markers <- FindAllMarkers(sc, test.use = "MAST", only.pos = FALSE, min.pct = 0.1, verbose = F)
    seurat.markers.summary <- as.data.frame(seurat.markers %>% group_by(cluster) %>% dplyr::filter(p_val_adj < 0.05) %>% top_n(50, abs(avg_log2FC)))
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = F)
    return(list(all = seurat.markers, top = seurat.markers.summary))
}

resDEG <- 'SCT_snn_res.0.05'
sc_subset <- PrepSCTFindMarkers(sc_subset)  # Object contains multiple models with unequal library sizes. Run `PrepSCTFindMarkers()` before running `FindMarkers()`
sc.markers.mas.res <- fmas(sc_subset, resDEG)
saveRDS(sc.markers.mas.res, paste0(rds_path, "sc.markers.mas.AT2subset.", resDEG, ".Rds"))

resDEG <- 'SCT_snn_res.0.2'
sc.markers.mas.res.2 <- fmas(sc_subset, resDEG)
saveRDS(sc.markers.mas.res.2, paste0(rds_path, "sc.markers.mas.AT2subset.", resDEG, ".Rds"))

Idents(sc_subset) <- "experiment"

# Define the function again for clarity
fmas.pair <- function(sc, res, id1, id2, suffix, logfc.threshold = 0.25) {
    file_out <- paste0(calculations_path, "DEG.AT2subset.pairwise.", suffix, ".xlsx")
    seurat.markers <- FindMarkers(
        sc, 
        test.use = "MAST", 
        only.pos = FALSE, 
        min.pct = 0.1, 
        logfc.threshold = logfc.threshold, 
        verbose = FALSE, 
        group.by = res,
        ident.1 = id1, 
        ident.2 = id2
    )
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = TRUE)
    return(seurat.markers)
}


# Now, run your desired comparisons
mas.Z_vs_wt <- fmas.pair(sc_subset, res = "experiment", id1 = "Z",   id2 = "wt", suffix = "Z_vs_wt")
mas.M_vs_wt <- fmas.pair(sc_subset, res = "experiment", id1 = "M",   id2 = "wt", suffix = "M_vs_wt")
mas.Z_vs_M  <- fmas.pair(sc_subset, res = "experiment", id1 = "Z",   id2 = "M",  suffix = "Z_vs_M")
saveRDS(mas.Z_vs_wt, paste0(rds_path, "sc.markers.mas.AT2subset.Z_vs_wt.Rds"))
saveRDS(mas.M_vs_wt, paste0(rds_path, "sc.markers.mas.AT2subset.M_vs_wt.Rds"))
saveRDS(mas.Z_vs_M, paste0(rds_path, "sc.markers.mas.AT2subset.Z_vs_M.Rds"))


```

```{r GSEA, eval=FALSE}
library(fgsea)
library(msigdbr)
library(data.table)

# -- Hallmarks --
msig.H <- msigdbr(species = "Mus musculus", collection = "H")
msig.H <- split(msig.H$gene_symbol, msig.H$gs_name)
# msigdbr_collections(db_species = "Mm")

run_fgsea_per_cluster <- function(seurat.markers, msig.H, out_prefix, scoreType = "std") {
  clusters <- unique(seurat.markers$cluster)
  gsea_list <- list()
  for (cl in clusters) {
    # Subset for cluster
    deg <- subset(seurat.markers, cluster == cl)
    deg <- deg[!duplicated(deg$gene),]
    ranks <- deg$avg_log2FC
    names(ranks) <- deg$gene
    ranks <- ranks[is.finite(ranks)]  # Remove NA/Inf
    fgsea_res <- fgsea(
      pathways = msig.H, 
      stats = ranks, 
      minSize = 5,
      maxSize = 500,
      scoreType = scoreType
    )
    fgsea_res$cluster <- cl

    gsea_list[[as.character(cl)]] <- fgsea_res
    # Write per-cluster file
    # data.table::fwrite(fgsea_res[order(pval)], 
    #  file=sprintf("%s_cluster_%s.tsv", out_prefix, cl), sep="\t") # no need to write separately
    
    # just for plotting
    fgsea_res$Significance <- factor(ifelse(fgsea_res$padj < 0.05, "padj < 0.05", "Not sig."),
                                     levels=c("padj < 0.05", "Not sig."))
    fgsea_res$`-log(P-value)` <- -log10(fgsea_res$pval)
    fgsea_res$pretty_pathway <- gsub("HALLMARK_", "", fgsea_res$pathway)
    fgsea_res$pretty_pathway <- gsub("_", " ", fgsea_res$pretty_pathway)
    fgsea_res_ord <- fgsea_res[order(abs(fgsea_res$NES), decreasing=TRUE), ]
    p <- ggplot(fgsea_res_ord, aes(x=reorder(pretty_pathway, NES), y=NES, fill=Significance)) +
        geom_bar(stat='identity') +
        coord_flip() +
        theme_minimal() +
        ggtitle(paste("Enriched Hallmarks NES \n", sub("^.*SCT","res",basename(out_prefix)), " cluster ", cl)) +
        theme(axis.text=element_text(size=7, face = "bold"), axis.title.y=element_blank()) +
        scale_fill_manual(name = "Significance", values = c("padj < 0.05"="grey20", "Not sig."="grey")) +
        ylab("Evidence of enrichment [NES]")
    ggsave(file.path(plots_path, paste0("Bar.ALL.", basename(out_prefix), ".cluster_", make.names(cl), ".NES.pdf")),
             p, width=9, height=9, limitsize = FALSE)
  }
  fgsea_all <- data.table::rbindlist(gsea_list)
  data.table::fwrite(fgsea_all, file=sprintf("%s_ALL.tsv", out_prefix), sep="\t")
  invisible(fgsea_all)
}


resDEG <- 'SCT_snn_res.0.05'
sc.markers.mas.res.includes.neg.05 <- fmas_includesNeg(sc_subset, resDEG)

run_fgsea_per_cluster(
  seurat.markers = sc.markers.mas.res.includes.neg.05$all,
  msig.H = msig.H,
  out_prefix = paste0(calculations_path, "GSEA_Hallmarks_SCT.0.05")
)

resDEG <- 'SCT_snn_res.0.2'
sc.markers.mas.res.includes.neg.2 <- fmas_includesNeg(sc_subset, resDEG)

run_fgsea_per_cluster(
  seurat.markers = sc.markers.mas.res.includes.neg.2$all,
  msig.H = msig.H,
  out_prefix = paste0(calculations_path, "GSEA_Hallmarks_SCT.0.2")
)

fmas.pair <- function(sc, res, id1, id2, suffix, logfc.threshold = 0.25) {
    file_out <- paste0(calculations_path, "DEG.AT2subset.pairwise.", suffix, ".xlsx")
    seurat.markers <- FindMarkers(
        sc, 
        test.use = "MAST", 
        only.pos = FALSE, 
        min.pct = 0.1, 
        logfc.threshold = logfc.threshold, 
        verbose = FALSE, 
        group.by = res,
        ident.1 = id1, 
        ident.2 = id2
    )
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = TRUE) # not saving, just finding markers for GSEA with less stringent logFC thres, so that there are more pos and neg markers
    return(seurat.markers)
}

mas.Z_vs_wt <- fmas.pair(sc_subset, res = "experiment", id1 = "Z",   id2 = "wt", suffix = "Z_vs_wt", logfc.threshold = 0.1)
mas.Z_vs_wt$gene <- rownames(mas.Z_vs_wt)
mas.Z_vs_wt$cluster <- "Z_vs_wt"
table(mas.Z_vs_wt$avg_log2FC > 0)
mas.M_vs_wt <- fmas.pair(sc_subset, res = "experiment", id1 = "M",   id2 = "wt", suffix = "M_vs_wt", logfc.threshold = 0.1)
mas.M_vs_wt$gene <- rownames(mas.M_vs_wt)
mas.M_vs_wt$cluster <- "M_vs_wt"
mas.Z_vs_M <- fmas.pair(sc_subset, res = "experiment", id1 = "Z",   id2 = "M", suffix = "Z_vs_M", logfc.threshold = 0.1)
mas.Z_vs_M$gene <- rownames(mas.Z_vs_M)
mas.Z_vs_M$cluster <- "Z_vs_M"
mas.experiment <- data.table::rbindlist(list(mas.Z_vs_wt, mas.M_vs_wt, mas.Z_vs_M ))
run_fgsea_per_cluster(
  seurat.markers = mas.experiment,
  msig.H = msig.H,
  out_prefix = paste0(calculations_path, "GSEA_Hallmarks_Experiment"),
  scoreType = "pos"
)

# Run FGSEA for Z vs M on each cell-type
library(MAST)
sc <- PrepSCTFindMarkers(sc)  # Object contains multiple models with unequal library sizes. Run `PrepSCTFindMarkers()` before running `FindMarkers()`
# Extract unique cell types from sc$annot_supervised (assuming it exists as metadata)
cell_types <- unique(sc$annot_supervised)

all_markers_list <- list()

table(sc$experiment, sc$annot_supervised)
Idents(sc) <- "annot_supervised"
sc <- PrepSCTFindMarkers(sc)

for (cell_type in cell_types) {
  # Subset Seurat object for current cell type
  # Run markers for Z vs M using your fmas.pair function
  markers <- FindMarkers(
    sc, 
    ident.1 = "Z", 
    ident.2 = "M", 
    logfc.threshold = 0.1, 
    test.use = "wilcox",
    group.by = "experiment", 
    subset.ident = cell_type,
    recorrect_umi = FALSE
  ) # fast implementation
  
  # Add gene and cluster (cell type) columns
  markers$gene <- rownames(markers)
  markers$cluster <- cell_type
  
  # Store in list
  all_markers_list[[cell_type]] <- markers
}

# Combine all markers from all cell types
mas.Z_vs.M.by_celltype <- data.table::rbindlist(all_markers_list)

# Run fgsea per cluster (cell type)
run_fgsea_per_cluster(
  seurat.markers = mas.Z_vs.M.by_celltype,
  msig.H = msig.H,
  out_prefix = paste0(calculations_path, "GSEA_Hallmarks_Experiment_Z_vs_M_perCellType"),
  scoreType = "std"
)
```


Hallmarks GSEA for each cell-type: 

Z vs WT 
and M vs WT

(get leadingEdge for those)

Volcano plot (pseudobulk expression) for:

Z vs M AT2s
Z vs WT AT2s
and M vs WT AT2s



## GSEA and Volcano

```{r combo_gsea_deg, eval=FALSE}
# For each cell-type in annot_supervised:
#   for contrast in experiment Z vs wt, and M vs wt and Z vs M:
#     run pairwise findmarkers:
#     run fGSEA on hallmarks using findmarkers results
#     visualize fGSEA results on NES barplot
#     if cell-type == "AT2" then visualize pairwise DEG results in Volcano plot
# rbind and write to file DEG results in a single table results of pairwise find markers for all contrasts and cell-types
# rbind and write to file fGSEA results in another single table for all contrasts and cell-types
library(ggrepel) # for geom_text_repel in volcano plot

# msigdbr Hallmark list
msig.H <- msigdbr(species = "Mus musculus", collection = "H")
msig.H <- split(msig.H$gene_symbol, msig.H$gs_name)

# -- Core contrasst definitions --
contrast_list <- list(
  "Z_vs_wt" = list(ident.1 = "Z", ident.2 = "wt"),
  "M_vs_wt" = list(ident.1 = "M", ident.2 = "wt"),
  "Z_vs_M"  = list(ident.1 = "Z", ident.2 = "M")
)

cell_types <- levels(sc$annot_supervised)
all_markers_list <- list()
all_fgsea_list   <- list()

# Set cell type as identity for subsetting
Idents(sc) <- "annot_supervised"
sc <- PrepSCTFindMarkers(sc)


for (cell_type in cell_types) {
  for (contrast_name in names(contrast_list)) {
    con <- contrast_list[[contrast_name]]
    # FindMarkers over only this cell type
    markers <- FindMarkers(
      sc,
      # subset to this cell type
      ident.1 = con$ident.1,
      ident.2 = con$ident.2,
      logfc.threshold = 0.1, 
      test.use = "wilcox",
      group.by = "experiment", 
      subset.ident = cell_type,
      recorrect_umi = FALSE
    )
    markers$gene <- rownames(markers)
    markers$cluster <- cell_type
    markers$contrast <- contrast_name
    
    # add to DEG result list
    all_markers_list[[paste(cell_type, contrast_name, sep = "_")]] <- markers
    
    # Run fgsea for this marker result
    myranks <- markers$avg_log2FC
    names(myranks) <- markers$gene
    myranks <- myranks[is.finite(myranks)]
    fgsea_res <- fgsea(
      pathways = msig.H,
      stats = myranks,
      minSize = 5,
      maxSize = 500,
      scoreType = "std"
    )
    fgsea_res$cluster <- cell_type
    fgsea_res$contrast <- contrast_name
    
    # Add to GSEA result list
    all_fgsea_list[[paste(cell_type, contrast_name, sep = "_")]] <- fgsea_res
    
    # --- fgsea NES barplot ---
    fgsea_res$Significance <- factor(ifelse(fgsea_res$padj < 0.05, "padj < 0.05", "Not sig."),
                                     levels=c("padj < 0.05", "Not sig."))
    fgsea_res$`-log(P-value)` <- -log10(fgsea_res$pval)
    fgsea_res$pretty_pathway <- gsub("HALLMARK_", "", fgsea_res$pathway)
    fgsea_res$pretty_pathway <- gsub("_", " ", fgsea_res$pretty_pathway)
    fgsea_res_ord <- fgsea_res[order(abs(fgsea_res$NES), decreasing=TRUE), ]
    p <- ggplot(fgsea_res_ord, aes(x=reorder(pretty_pathway, NES), y=NES, fill=Significance)) +
      geom_bar(stat='identity') +
      coord_flip() +
      theme_minimal() +
      ggtitle(sprintf("Enriched Hallmarks NES\nCell type: %s, Contrast: %s", cell_type, contrast_name)) +
      theme(axis.text=element_text(size=7, face = "bold"), axis.title.y=element_blank()) +
      scale_fill_manual(name = "Significance", values = c("padj < 0.05"="grey20", "Not sig."="grey")) +
      ylab("Evidence of enrichment [NES]")
    ggsave(file.path(plots_path, sprintf("Bar.%s.%s.NES.pdf", make.names(cell_type), contrast_name)),
           p, width=9, height=9, limitsize = FALSE)
    
    # --- Volcano plot (for AT2 only) ---
    if (cell_type == "AT2") {
      markers$logFC <- markers$avg_log2FC
      markers$SYMBOL <- markers$gene
      
      markers$Significance <- ifelse(markers$p_val_adj < 0.05,
                                     ifelse(markers$logFC > 0, "Up", "Down"),
                                     "Not sig.")
      markers$Significance <- factor(markers$Significance, levels = c("Up", "Not sig.", "Down"))
      
      # Top up, down, most significant, up to 10 each
      topN <- 10
      upgenes <- markers[markers$Significance == "Up", ] %>% arrange(-logFC) %>% head(topN) %>% pull(SYMBOL)
      downgenes <-  markers[markers$Significance == "Down", ] %>% arrange(logFC) %>% head(topN) %>% pull(SYMBOL)
      siggenes <- markers%>% arrange(p_val) %>% head(topN) %>% pull(SYMBOL)
      to_label <- unique(c(upgenes, downgenes, siggenes))
      
      pp <- ggplot(markers, aes(x = logFC, y = -log10(p_val))) +
        geom_point(aes(color = Significance), alpha = 0.5, size = 2) +
        scale_color_manual(values = c("Up" = "red", "Not sig." = "grey", "Down" = "blue")) +
        theme_bw(base_size = 14) +
        labs(y = "-log10(P-value)", x = "log2 fold-change",
             title = paste("Volcano plot: AT2, Contrast:", contrast_name)) +
        geom_text_repel(
          data = subset(markers, SYMBOL %in% to_label),
          aes(label = SYMBOL),
          size = 4,
          box.padding = 0.35,
          point.padding = 0.3,
          max.overlaps = 20
        )
      ggsave(file.path(plots_path, sprintf("Volcano.AT2.%s.pdf", contrast_name)),
             pp, width = 9, height = 7)
    }
  }
}

# ---- output files -----
## Combine marker results
all_deg_tab <- data.table::rbindlist(all_markers_list, fill=TRUE)
data.table::fwrite(all_deg_tab, file=file.path(calculations_path, "DEG_results_pairwise_allCellTypes_contrasts.tsv"), sep="\t")

## Combine fgsea results
all_fgsea_tab <- data.table::rbindlist(all_fgsea_list, fill=TRUE)
data.table::fwrite(all_fgsea_tab, file=file.path(calculations_path, "fgsea_Hallmarks_pairwise_allCellTypes_contrasts.tsv"), sep="\t")

```

## Ann plot

```{r}
newmeta <- sc[[]]

# now recode
sc$annot_supervised <- fct_recode(
  sc$seurat_clusters,
  "AT2"                          = "0",
  "endothelial"                  = "1",
  "fibroblasts/myofibroblasts"   = "2",
  "endothelial"                  = "3",
  "monocytes/macrophages"        = "4",
  "AT2"                          = "5",
  "Ciliated"                     = "6",
  "B"                            = "7",
  "undetermined"                 = "8",
  "T/NK"                         = "9",
  "Basal"                        = "10",
  "AT1"                          = "11",
  "mesothelial"                  = "12",
  "secretory"                    = "13",
  "undetermined"                 = "14",
  "undetermined"                 = "15"
)
saveRDS(sc, paste0(rds_path, "sc.Rds"))

```

# Pseudobulk RNA-seq

```{r}
sc_subset <- readRDS("/restricted/projectnb/crem-bioinfo/project_workspace/25_07_03_Carly/calculations/analysis/combined/rds/sc_subset.AT2.Rds")

pseudo_sc <- AggregateExpression(sc_subset, assays = "RNA", return.seurat = T, group.by = c("orig.ident", "experiment", "annot_supervised"))


Idents(pseudo_sc) <- "experiment"
pseudo_sc[[]]

# Define the function again for clarity
fdeseq.pseudo.pair <- function(sc, res, id1, id2, suffix, logfc.threshold = 0.01) {
    file_out <- paste0(calculations_path, "DEG.AT2subset.pairwise.pseudobulk.", suffix, ".xlsx")
    seurat.markers <- FindMarkers(
        sc, 
        test.use = "DESeq2", 
        only.pos = FALSE, 
        min.pct = 0.1, 
        logfc.threshold = logfc.threshold, 
        verbose = FALSE, 
        group.by = res,
        ident.1 = id1, 
        ident.2 = id2
    )
    openxlsx::write.xlsx(seurat.markers, file_out, zoom = 100, asTable = TRUE, tableStyle = "none", rowNames = TRUE)
    return(seurat.markers)
}


# Now, run your desired comparisons
fdeseq.Z_vs_wt <- fdeseq.pseudo.pair(pseudo_sc, res = "experiment", id1 = "Z",   id2 = "wt", suffix = "Z_vs_wt")
fdeseq.M_vs_wt <- fdeseq.pseudo.pair(pseudo_sc, res = "experiment", id1 = "M",   id2 = "wt", suffix = "M_vs_wt")
fdeseq.Z_vs_M  <- fdeseq.pseudo.pair(pseudo_sc, res = "experiment", id1 = "Z",   id2 = "M",  suffix = "Z_vs_M")
saveRDS(fdeseq.Z_vs_wt, paste0(rds_path, "sc.markers.fdeseq.pseudobulk.AT2subset.Z_vs_wt.Rds"))
saveRDS(fdeseq.M_vs_wt, paste0(rds_path, "sc.markers.fdeseq.pseudobulk.AT2subset.M_vs_wt.Rds"))
saveRDS(fdeseq.Z_vs_M, paste0(rds_path, "sc.markers.fdeseq.pseudobulk.AT2subset.Z_vs_M.Rds"))

res.list <- list(fdeseq.Z_vs_wt, fdeseq.M_vs_wt, fdeseq.Z_vs_M)
sig.any2 <- unique(unlist(
  lapply(res.list, function(df) rownames(df)[ df$p_val_adj < 0.05 ])
))
length(sig.any2)


genes <- sig.any2[!is.na(sig.any2)]
pseudo_sc <- ScaleData(pseudo_sc, features = genes, verbose = FALSE)
g <- DoHeatmap(pseudo_sc, features = genes, group.by = "experiment")
ggsave(paste0(plots_path, "Hm.Pseudobulk.Sig.anycontrast.pdf"), width = 10, height = 20, limitsize = FALSE)


get_top5 <- function(df, fc.col="avg_log2FC", n=5){
  # assumes rownames(df) are your gene names
  # most up = largest avg_log2FC
  up   <- head(rownames(df[order(-df[[fc.col]]), , drop=FALSE]), n)
  # most down = smallest avg_log2FC
  down <- head(rownames(df[order( df[[fc.col]]), , drop=FALSE]), n)
  list(up=up, down=down)
}
top.Z_wt <- get_top5(fdeseq.Z_vs_wt)
top.M_wt <- get_top5(fdeseq.M_vs_wt)
top.Z_M  <- get_top5(fdeseq.Z_vs_M)

gene_list <- c(
  top.Z_wt$up,   top.Z_wt$down,
  top.M_wt$up,   top.M_wt$down,
  top.Z_M$up,    top.Z_M$down
)
contrast_label <- rep(c(
  "Z_vs_wt_up",   "Z_vs_wt_down",
  "M_vs_wt_up",   "M_vs_wt_down",
  "Z_vs_M_up",    "Z_vs_M_down"
), each = 5)

annotation_row <- data.frame(contrast=contrast_label, gene = gene_list)
annotation_row <- annotation_row
rownames(annotation_row) <- make.names(gene_list)
library(pheatmap)

res.list <- list(fdeseq.Z_vs_wt, fdeseq.M_vs_wt, fdeseq.Z_vs_M)
sig.any <- unique(unlist(
  lapply(res.list, function(df) rownames(df)[ df$p_val_adj < 0.2 ])
))
length(sig.any)
gene_list <- sig.any[!is.na(sig.any)]

# pull out the expression for those genes (+ any cell‐meta you like)
df_exp <- FetchData(pseudo_sc, 
                    vars = c(gene_list, "orig.ident","experiment"))

# make a numeric matrix genes × cells
mat <- t(as.matrix(df_exp[, gene_list, drop=FALSE]))

# IMPORTANT: force the rows into your desired order
mat <- mat[gene_list, , drop=FALSE]

# column annotations (if you want to color‐code cells by experiment or orig.ident)
annotation_col <- data.frame(
  experiment = df_exp$experiment,
  orig.ident = df_exp$orig.ident
)
rownames(annotation_col) <- rownames(df_exp)

# draw the heatmap
p <- pheatmap(
  mat,
  scale            = "row",        # Z‐score each gene
  cluster_rows     = TRUE,        # do NOT re‐cluster rows
  cluster_cols     = FALSE,         # up to you…
  annotation_row   = NULL,
  annotation_col   = annotation_col,
  show_rownames    = TRUE,
  show_colnames    = FALSE
)

save_pheatmap_pdf(p, paste0(master_path, "/analysis/combined/plots/Hm.pseudobulk.topDEG.pdf"), height = 10)


save_pheatmap_pdf <- function(x, filename, height, width) {
  pdf(filename, height = height, width = width)

  grid::grid.newpage()
  grid::grid.draw(x)
  dev.off()
}


res.list <- list(fdeseq.Z_vs_M)
sig.any <- unique(unlist(
  lapply(res.list, function(df) rownames(df)[ df$p_val_adj < 0.2 ])
))
length(sig.any)
gene_list <- sig.any[!is.na(sig.any)]

# pull out the expression for those genes (+ any cell‐meta you like)
df_exp <- FetchData(subset(pseudo_sc, subset = experiment != "wt"), vars = c(gene_list, "orig.ident","experiment"))

# make a numeric matrix genes × cells
mat <- t(as.matrix(df_exp[, gene_list, drop=FALSE]))

# IMPORTANT: force the rows into your desired order
mat <- mat[gene_list, , drop=FALSE]

# column annotations (if you want to color‐code cells by experiment or orig.ident)
annotation_col <- data.frame(
  experiment = df_exp$experiment,
  orig.ident = df_exp$orig.ident
)
rownames(annotation_col) <- rownames(df_exp)

# draw the heatmap
p <- pheatmap(
  mat,
  scale            = "row",        # Z‐score each gene
  cluster_rows     = TRUE,        # do NOT re‐cluster rows
  cluster_cols     = FALSE,         # up to you…
  annotation_row   = NULL,
  annotation_col   = annotation_col,
  show_rownames    = TRUE,
  show_colnames    = FALSE
)

save_pheatmap_pdf(p, paste0(master_path, "/analysis/combined/plots/Hm.pseudobulk.topDEG.ZvsM.woWT.pdf"), height = 10)

```

# ShinyCell


```{r ShinyCellxplorer}
library(Seurat)
devtools::install_github("SGDDNB/ShinyCell")

library(ShinyCell)
library(data.table)
library(Signac)
dir.create(paste0(calculations_path, "shinycell"))
setwd(paste0(calculations_path, "shinycell"))
sc <- readRDS(paste0(rds_path, "sc.Rds"))
var_features <- VariableFeatures(sc)
saveRDS(var_features, "var_features.rds")

seu <- sc
scConf <- createConfig(seu)
makeShinyApp(seu, scConf, gex.assay = c("SCT"), gene.mapping = TRUE , shiny.title = "x" , shiny.footnotes='Center for Regenerative Medicine', shiny.dir=paste0(calculations_path, "shinycell")) 

cd /restricted/projectnb/crem-bioinfo/project_workspace/test
cp cellxwoprest/cellxplorer/server.R  /restricted/projectnb/crem-bioinfo//project_workspace/25_07_03_Carly/calculations/combined_harmony/shinycell/server.R
cp cellxwoprest/cellxplorer/ui.R /restricted/projectnb/crem-bioinfo//project_workspace/25_07_03_Carly/calculations/combined_harmony/shinycell/ui.R
```


```{r azi}
#sc <- readRDS(paste0(rds_path, "sc.Rds"))
library(Azimuth)
library(SeuratData)

DefaultAssay(sc) <- "RNA"
sc[["RNA"]] <- JoinLayers(sc[["RNA"]])
sc <- RunAzimuth(sc, reference = "/restricted/projectnb/crem-bioinfo/reference_data/REFERENCES/Azimuth/pansci_full/")

saveRDS(sc, paste0(rds_path, "sc.Rds"))
```
